<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>The Daily Blade â€” Pulp Fantasy</title>
<link rel="preconnect" href="https://fonts.googleapis.com" />
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Cinzel+Decorative:wght@700&family=IM+Fell+English:ital@0;1&display=swap" rel="stylesheet" />
<style>
/* â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --ink: #1a0d05;
  --parchment: #f4e8cf;
  --aged: #e2d0a8;
  --blood: #8b1a1a;
  --gold: #c9922a;
  --darkgold: #7a4f0d;
  --shadow: #2a1505;
  --muted: #5c3d1e;
}
html { scroll-behavior: smooth; }
body { background: var(--ink); color: var(--parchment); font-family: 'IM Fell English', Georgia, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; min-height: 100vh; line-height: 1.7; }
body::before { content: ''; position: fixed; inset: 0; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='300' height='300'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.75' numOctaves='4' stitchTiles='stitch'/%3E%3CfeColorMatrix type='saturate' values='0'/%3E%3C/filter%3E%3Crect width='300' height='300' filter='url(%23n)' opacity='0.07'/%3E%3C/svg%3E"); pointer-events: none; z-index: 0; opacity: 0.4; }
.page-wrap { position: relative; z-index: 1; max-width: 1100px; margin: 0 auto; padding: 0 1.5rem 4rem; }

/* â”€â”€ Masthead â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.masthead { text-align: center; padding: 2.5rem 1rem 1.5rem; border-bottom: 3px double var(--gold); }
.masthead::after { content: 'âš” âœ¦ âš”'; display: block; color: var(--gold); font-size: 1.1rem; letter-spacing: .4em; margin-top: .5rem; }
.masthead-eyebrow { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .72rem; letter-spacing: .35em; color: var(--gold); text-transform: uppercase; margin-bottom: .5rem; }
.masthead-title { font-family: 'Cinzel Decorative', 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: clamp(2.4rem, 7vw, 5rem); font-weight: 700; color: var(--parchment); text-shadow: 3px 3px 0 var(--blood), 5px 5px 10px rgba(0,0,0,.7); line-height: 1.1; letter-spacing: .03em; }
.masthead-sub { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .8rem; letter-spacing: .25em; color: var(--aged); margin-top: .6rem; }
.masthead-date { margin-top: .8rem; font-style: italic; font-size: .85rem; color: var(--gold); }

/* â”€â”€ Main Nav Tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.main-nav { display: flex; align-items: center; gap: 0; padding: 1.5rem 0 0; border-bottom: 2px solid rgba(201,146,42,.25); }
.main-tab { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .72rem; letter-spacing: .22em; text-transform: uppercase; background: none; border: none; border-bottom: 3px solid transparent; margin-bottom: -2px; color: var(--muted); padding: .6rem 1.2rem .7rem; cursor: pointer; transition: color .18s, border-color .18s; white-space: nowrap; }
.main-tab:hover { color: var(--aged); }
.main-tab.active { color: var(--gold); border-bottom-color: var(--gold); }
.main-nav-right { margin-left: auto; display: flex; align-items: center; gap: .6rem; padding-bottom: .4rem; }

/* â”€â”€ Genre Filter Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.genre-bar { display: flex; flex-wrap: wrap; gap: .45rem; padding: 1.1rem 0 .8rem; border-bottom: 1px solid rgba(201,146,42,.15); margin-bottom: 1.8rem; }
.genre-btn { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .6rem; letter-spacing: .18em; text-transform: uppercase; background: none; border: 1px solid rgba(201,146,42,.3); color: var(--muted); padding: .3rem .75rem; border-radius: 2px; cursor: pointer; transition: background .15s, color .15s, border-color .15s; white-space: nowrap; }
.genre-btn:hover { border-color: var(--gold); color: var(--aged); }
.genre-btn.active { background: rgba(201,146,42,.15); border-color: var(--gold); color: var(--gold); }

/* â”€â”€ Controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.controls { display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 1rem; padding: .6rem 0 .5rem; margin-bottom: .4rem; }
.controls-left { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .72rem; letter-spacing: .2em; color: var(--gold); text-transform: uppercase; }
.controls-right { display: flex; align-items: center; gap: .5rem; flex-wrap: wrap; justify-content: flex-end; }

.codex-organize-label { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .62rem; letter-spacing: .18em; text-transform: uppercase; color: rgba(201,146,42,.65); }
.codex-organize-select {
  font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif;
  font-size: .62rem;
  letter-spacing: .14em;
  text-transform: uppercase;
  color: var(--gold);
  background: rgba(18, 8, 3, .92);
  border: 1px solid rgba(201,146,42,.35);
  padding: .3rem 2.0rem .3rem .55rem;
  border-radius: 2px;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  color-scheme: dark;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 18 18'%3E%3Cpath d='M4.5 7.2 L9 11.5 L13.5 7.2' fill='none' stroke='%23c9922a' stroke-width='1.8' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right .55rem center;
  background-size: 1rem;
}
.codex-organize-select:focus { border-color: rgba(201,146,42,.75); box-shadow: 0 0 0 2px rgba(201,146,42,.12); }
.codex-organize-select option { background: #120803; color: var(--gold); }

.codex-group-header { grid-column: 1 / -1; border-top: 1px solid rgba(201,146,42,.22); border-bottom: 1px solid rgba(201,146,42,.12); padding: .75rem .2rem .65rem; margin: .4rem 0 -.35rem; display: flex; align-items: baseline; justify-content: space-between; gap: 1rem; }
.codex-group-title { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .72rem; letter-spacing: .22em; text-transform: uppercase; color: rgba(226,208,168,.9); }
.codex-group-count { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .58rem; letter-spacing: .18em; text-transform: uppercase; color: rgba(201,146,42,.55); }

/* â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.btn { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .65rem; letter-spacing: .2em; text-transform: uppercase; border: 1px solid var(--gold); background: transparent; color: var(--gold); padding: .4rem .9rem; border-radius: 2px; cursor: pointer; transition: background .18s, color .18s; white-space: nowrap; }
.btn:hover { background: var(--gold); color: var(--ink); }
.btn-blood { border-color: var(--blood); color: var(--blood); }
.btn-blood:hover { background: var(--blood); color: var(--parchment); }

/* â”€â”€ Status â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#status-msg { text-align: center; padding: 3rem 1rem; font-style: italic; color: var(--aged); }
.spinner { display: inline-block; width: 1.4rem; height: 1.4rem; border: 3px solid rgba(201,146,42,.2); border-top-color: var(--gold); border-radius: 50%; animation: spin 0.9s linear infinite; vertical-align: middle; margin-right: .6rem; }
@keyframes spin { to { transform: rotate(360deg); } }

/* â”€â”€ Story Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.story-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(480px, 1fr)); gap: 1.8rem; }
@media (max-width: 560px) { .story-grid { grid-template-columns: 1fr; } }

/* â”€â”€ Story Card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.story-card { background: linear-gradient(160deg, #1e0e06 0%, #130b04 100%); border: 1px solid rgba(201,146,42,.35); border-top: 3px solid var(--blood); border-radius: 3px; padding: 1.5rem 1.8rem 1.6rem; position: relative; overflow: hidden; box-shadow: 0 4px 20px rgba(0,0,0,.5); transition: transform .2s, box-shadow .2s; }
.story-card.hidden { display: none; }
.story-card:hover { transform: translateY(-2px); box-shadow: 0 8px 28px rgba(0,0,0,.65); }
.story-card::before { content: 'âœ¦'; position: absolute; top: .6rem; right: .9rem; color: var(--blood); font-size: .8rem; opacity: .6; }
.story-number { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .65rem; letter-spacing: .3em; color: var(--blood); text-transform: uppercase; margin-bottom: .3rem; }
.story-tag { display: inline-block; font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .6rem; letter-spacing: .2em; text-transform: uppercase; color: var(--gold); border: 1px solid rgba(201,146,42,.4); padding: .15rem .5rem; border-radius: 2px; margin-bottom: .7rem; cursor: pointer; transition: background .15s, color .15s; }
.story-tag:hover { background: rgba(201,146,42,.15); }
.story-title { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: 1.12rem; font-weight: 700; color: var(--parchment); line-height: 1.3; margin-bottom: .9rem; text-shadow: 1px 1px 4px rgba(0,0,0,.6); }
.story-divider { border: none; border-top: 1px solid rgba(201,146,42,.25); margin-bottom: .9rem; }
.story-text { font-size: .9rem; color: var(--aged); line-height: 1.75; text-align: justify; hyphens: auto; }
.story-text::first-letter { float: left; font-family: 'Cinzel Decorative', 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: 3.2rem; line-height: .75; padding-right: .12em; color: var(--gold); text-shadow: 2px 2px 4px rgba(0,0,0,.7); }

/* â”€â”€ Story Entities (badges under each story) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.story-entities { margin-top: .85rem; padding-top: .85rem; border-top: 1px solid rgba(201,146,42,.18); display: grid; gap: .55rem; }
.story-entities-row { display: flex; align-items: baseline; gap: .65rem; flex-wrap: wrap; }
.story-entities-label { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .58rem; letter-spacing: .2em; text-transform: uppercase; color: rgba(201,146,42,.6); white-space: nowrap; }
.story-entities-badges { display: flex; flex-wrap: wrap; gap: .35rem; }
.entity-badge { cursor: pointer; background: rgba(0,0,0,.14); }
.entity-badge:hover { border-color: rgba(201,146,42,.6); color: var(--parchment); }
.entity-badge:focus { outline: 2px solid rgba(201,146,42,.45); outline-offset: 2px; }

.entity-link {
  display: inline;
  font: inherit;
  background: none;
  border: none;
  padding: 0;
  margin: 0;
  color: var(--gold);
  cursor: pointer;
  text-decoration: underline;
  text-decoration-color: rgba(201,146,42,.55);
  text-decoration-thickness: 1px;
  text-underline-offset: .12em;
}
.entity-link:hover { color: var(--parchment); text-decoration-color: var(--gold); }
.entity-link:focus { outline: 2px solid rgba(201,146,42,.55); outline-offset: 2px; border-radius: 2px; }

.codex-card.codex-flash { box-shadow: 0 0 0 2px rgba(201,146,42,.6), 0 10px 30px rgba(0,0,0,.6) !important; }

/* â”€â”€ No Results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.no-results { text-align: center; padding: 3rem 1rem; font-style: italic; color: var(--muted); grid-column: 1 / -1; }

/* â”€â”€ Codex View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
#char-view { display: none; }

/* â”€â”€ Codex Filter Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.codex-filter-bar { display: flex; flex-wrap: wrap; gap: .45rem; padding: 1.1rem 0 .8rem; border-bottom: 1px solid rgba(201,146,42,.15); margin-bottom: 1rem; }
.codex-filter-btn { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .6rem; letter-spacing: .18em; text-transform: uppercase; background: none; border: 1px solid rgba(201,146,42,.3); color: var(--muted); padding: .3rem .75rem; border-radius: 2px; cursor: pointer; transition: background .15s, color .15s, border-color .15s; white-space: nowrap; }
.codex-filter-btn:hover { border-color: var(--gold); color: var(--aged); }
.codex-filter-btn.active { background: rgba(201,146,42,.15); border-color: var(--gold); color: var(--gold); }

/* â”€â”€ Codex Grid â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.char-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1.5rem; margin-top: 1rem; }
@media (max-width: 400px) { .char-grid { grid-template-columns: 1fr; } }

/* â”€â”€ Shared Codex Card â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.codex-card { border-radius: 3px; padding: 1.4rem 1.5rem 1.5rem; position: relative; box-shadow: 0 3px 16px rgba(0,0,0,.45); transition: transform .2s, box-shadow .2s; min-width: 0; overflow-wrap: anywhere; word-break: break-word; }
.codex-card:hover { transform: translateY(-2px); box-shadow: 0 7px 24px rgba(0,0,0,.6); }
.codex-card.hidden { display: none; }
.codex-card.hidden-org { display: none; }
.codex-type-label { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .58rem; letter-spacing: .15em; text-transform: uppercase; color: rgba(201,146,42,.4); position: absolute; top: .6rem; right: .8rem; }
.codex-card-name { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: 1.05rem; font-weight: 700; color: var(--parchment); line-height: 1.2; text-shadow: 1px 1px 3px rgba(0,0,0,.5); padding-right: 5.5rem; overflow-wrap: anywhere; word-break: break-word; }
.codex-card-tagline { font-style: italic; color: var(--gold); font-size: .85rem; letter-spacing: .04em; margin: .3rem 0 .5rem; opacity: .9; }
.codex-card-badges { display: flex; flex-direction: row; flex-wrap: wrap; gap: 0.35rem; margin-top: 0.45rem; margin-bottom: 0.65rem; }
.codex-card-badges .badge { max-width: 100%; white-space: normal; overflow-wrap: anywhere; word-break: break-word; }
.codex-divider { border: none; border-top: 1px solid rgba(201,146,42,.2); margin: .8rem 0; }
.codex-card-footer { font-size: .75rem; color: var(--muted); font-style: italic; display: flex; align-items: center; justify-content: space-between; gap: .5rem; flex-wrap: wrap; padding-top: .6rem; border-top: 1px solid rgba(201,146,42,.12); margin-top: .6rem; }
.codex-appearances { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .6rem; letter-spacing: .1em; color: rgba(201,146,42,.5); white-space: nowrap; }
.codex-body { font-size: .875rem; color: var(--aged); line-height: 1.7; margin-bottom: .6rem; max-width: 100%; overflow-wrap: anywhere; word-break: break-word; }

/* Used by several codex card types (relics, lore, etc.) */
.codex-meta { display: flex; flex-wrap: wrap; gap: .5rem; align-items: baseline; color: var(--muted); font-style: italic; font-size: .75rem; }
.codex-meta span { overflow-wrap: anywhere; word-break: break-word; }

/* â”€â”€ Character Cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.char-card { background: linear-gradient(160deg, #1b0c05 0%, #110904 100%); border: 1px solid rgba(201,146,42,.3); border-top: 3px solid var(--darkgold); }
.badge { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .55rem; letter-spacing: .18em; text-transform: uppercase; padding: .18rem .5rem; border-radius: 2px; white-space: nowrap; background: rgba(0,0,0,.18); border: 1px solid rgba(201,146,42,.22); color: rgba(226,208,168,.9); }
.badge-role { background: rgba(201,146,42,.15); border: 1px solid rgba(201,146,42,.4); color: var(--gold); }
.badge-status-active { background: rgba(30,80,30,.3); border: 1px solid #3a8a3a; color: #6dbb6d; }
.badge-status-dead { background: rgba(80,10,10,.3); border: 1px solid #8b1a1a; color: #c96060; }
.badge-status-cursed { background: rgba(60,20,80,.3); border: 1px solid #7a3a9a; color: #b07acc; }
.badge-status-changed { background: rgba(20,50,70,.3); border: 1px solid #2a6a8a; color: #5aaabb; }
.badge-status-unknown { background: rgba(40,30,10,.3); border: 1px solid #6a5a1a; color: #9a8a4a; }
.badge-status-default { background: rgba(40,30,20,.3); border: 1px solid rgba(201,146,42,.3); color: var(--muted); }
.badge-faction { background: rgba(201,146,42,.12); border: 1px solid rgba(201,146,42,.45); color: var(--gold); }
.badge-lore { background: rgba(201,146,42,.08); border: 1px solid rgba(201,146,42,.35); color: rgba(226,208,168,.92); }
.badge-flora { background: rgba(74,120,30,.15); border: 1px solid rgba(74,120,30,.55); color: #7abb50; }
.badge-magic { background: rgba(60,20,80,.22); border: 1px solid rgba(122,58,154,.55); color: #c29ae2; }
.badge-relic { background: rgba(139,26,26,.12); border: 1px solid rgba(139,26,26,.45); color: #c96060; }
.badge-substance { background: rgba(160,80,30,.15); border: 1px solid rgba(160,80,30,.55); color: #d0844a; }
.badge-region { background: rgba(201,146,42,.10); border: 1px solid rgba(201,146,42,.35); color: rgba(201,146,42,.95); }
.badge-travel-local { background: rgba(40,30,20,.25); border: 1px solid rgba(201,146,42,.25); color: rgba(226,208,168,.8); }
.badge-travel-regional { background: rgba(20,50,70,.25); border: 1px solid rgba(42,106,138,.45); color: #7fc0cc; }
.badge-travel-realmwide { background: rgba(74,120,30,.18); border: 1px solid rgba(74,120,30,.55); color: #9ad07a; }
.badge-travel-interrealm { background: rgba(60,20,80,.25); border: 1px solid rgba(122,58,154,.55); color: #c29ae2; }
.badge-travel-unknown { background: rgba(40,30,20,.2); border: 1px solid rgba(201,146,42,.18); color: rgba(92,61,30,.95); }
.char-traits { display: flex; flex-wrap: wrap; gap: .35rem; margin-bottom: .6rem; }
.char-trait { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .55rem; letter-spacing: .15em; text-transform: uppercase; color: var(--blood); border: 1px solid rgba(139,26,26,.4); padding: .12rem .45rem; border-radius: 2px; }

/* â”€â”€ Place Cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.place-card { background: linear-gradient(160deg, #080d05 0%, #060a04 100%); border: 1px solid rgba(74,120,30,.3); border-top: 3px solid #3a7a1a; }
.badge-place { background: rgba(74,120,30,.15); border: 1px solid rgba(74,120,30,.5); color: #7abb50; }
.place-atmosphere { font-style: italic; color: rgba(226,208,168,.7); font-size: .85rem; margin-bottom: .6rem; }

/* â”€â”€ Geography (place cards) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.codex-geo-details { margin-top: .55rem; }
.codex-geo-details summary { cursor: pointer; font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .62rem; letter-spacing: .14em; text-transform: uppercase; color: rgba(201,146,42,.65); }
.codex-geo-details summary:hover { color: var(--gold); }
.codex-geo-chain { margin-top: .55rem; font-size: .78rem; color: var(--muted); font-style: italic; line-height: 1.5; }
.codex-geo-chain strong { font-style: normal; color: rgba(226,208,168,.75); font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .62rem; letter-spacing: .12em; text-transform: uppercase; margin-right: .35rem; }
.codex-geo-chain .geo-row { display: flex; gap: .5rem; flex-wrap: wrap; }

/* â”€â”€ Event Cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.event-card { background: linear-gradient(160deg, #0d0518 0%, #080313 100%); border: 1px solid rgba(100,50,160,.3); border-top: 3px solid #6a2a9a; }
.badge-event { background: rgba(100,50,160,.15); border: 1px solid rgba(100,50,160,.5); color: #b07acc; }
.event-participants { font-size: .8rem; color: var(--muted); margin: .2rem 0 .5rem; }
.event-participants strong { font-style: normal; color: rgba(176,122,204,.7); font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .6rem; letter-spacing: .12em; text-transform: uppercase; margin-right: .3rem; }
.event-significance { font-size: .82rem; color: rgba(176,122,204,.65); font-style: italic; margin-top: .3rem; }

/* â”€â”€ Weapon Cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.weapon-card { background: linear-gradient(160deg, #130a0a 0%, #0e0707 100%); border: 1px solid rgba(160,80,30,.3); border-top: 3px solid #9a4a1a; }
.badge-weapon { background: rgba(160,80,30,.15); border: 1px solid rgba(160,80,30,.5); color: #d0844a; }
.weapon-holder { font-size: .8rem; color: var(--muted); font-style: italic; margin-top: .3rem; }

/* â”€â”€ Artifact Cards â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.artifact-card { background: linear-gradient(160deg, #0e0d14 0%, #090810 100%); border: 1px solid rgba(80,100,180,.3); border-top: 3px solid #4a5aaa; }
.badge-artifact { background: rgba(80,100,180,.15); border: 1px solid rgba(80,100,180,.5); color: #8090dd; }
.artifact-holder { font-size: .8rem; color: var(--muted); font-style: italic; margin-top: .3rem; }

/* â”€â”€ Story Links (codex cards) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.codex-story-links { margin-top: .8rem; display: flex; flex-wrap: wrap; gap: .4rem; align-items: center; border-top: 1px solid rgba(201,146,42,.15); padding-top: .8rem; }
.codex-story-links-label { font-size: .7rem; color: var(--muted); text-transform: uppercase; letter-spacing: .1em; flex-basis: 100%; }
.codex-story-link { background: none; border: 1px solid rgba(201,146,42,.3); color: var(--gold); font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .72rem; padding: .25rem .65rem; cursor: pointer; transition: background .15s, color .15s, border-color .15s; border-radius: 2px; }
.codex-story-link:hover { background: rgba(201,146,42,.12); color: var(--parchment); border-color: rgba(201,146,42,.6); }

/* â”€â”€ Story Modal (single-story preview) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.story-modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.72); z-index: 120; opacity: 0; pointer-events: none; transition: opacity .22s ease; }
.story-modal-overlay.open { opacity: 1; pointer-events: all; }
.story-modal { position: fixed; inset: 0; z-index: 121; display: grid; place-items: center; padding: 1.2rem; opacity: 0; pointer-events: none; transition: opacity .22s ease; }
.story-modal.open { opacity: 1; pointer-events: all; }

/* Codex modal sits above the story modal when both are open */
#codex-modal-overlay { z-index: 130; }
#codex-modal { z-index: 131; }
.story-modal-panel { width: min(860px, 96vw); max-height: min(88vh, 860px); overflow: auto; background: linear-gradient(160deg, #1e0e06 0%, #130b04 100%); border: 1px solid rgba(201,146,42,.45); border-top: 3px solid var(--blood); border-radius: 4px; box-shadow: 0 14px 55px rgba(0,0,0,.75); padding: 1.25rem 1.35rem 1.35rem; position: relative; }
.story-modal-top { display: flex; align-items: flex-start; justify-content: space-between; gap: 1rem; margin-bottom: .5rem; }
.story-modal-title { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: 1.15rem; font-weight: 700; color: var(--parchment); line-height: 1.25; text-shadow: 1px 1px 4px rgba(0,0,0,.7); }
.story-modal-sub { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .62rem; letter-spacing: .22em; color: rgba(201,146,42,.75); text-transform: uppercase; margin-top: .25rem; }
.story-modal-close { background: none; border: 1px solid rgba(201,146,42,.35); color: var(--gold); font-size: 1.05rem; width: 2.1rem; height: 2.1rem; border-radius: 2px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: background .15s, color .15s; line-height: 1; }
.story-modal-close:hover { background: var(--gold); color: var(--ink); }
.story-modal-actions { display: flex; gap: .6rem; flex-wrap: wrap; align-items: center; margin-top: .65rem; }
.story-modal-actions .btn { padding: .35rem .8rem; }
.story-modal-actions .btn-icon { padding: .32rem .6rem; letter-spacing: .12em; }
.story-modal-actions .story-modal-count { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .6rem; letter-spacing: .22em; text-transform: uppercase; color: rgba(201,146,42,.65); margin-left: auto; }
.story-modal-text { font-size: .92rem; color: var(--aged); line-height: 1.75; text-align: justify; hyphens: auto; margin-top: .75rem; white-space: pre-wrap; }
.story-modal-text::first-letter { float: left; font-family: 'Cinzel Decorative', 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: 3.1rem; line-height: .75; padding-right: .12em; color: var(--gold); text-shadow: 2px 2px 4px rgba(0,0,0,.7); }

/* Codex modal body should not inherit story typography */
.codex-modal-body { margin-top: .75rem; }
.codex-modal-body .codex-card:hover { transform: none; box-shadow: 0 3px 16px rgba(0,0,0,.45); }
.codex-modal-body .codex-card { margin: 0; }

/* Characters loading/empty states */
.char-status { text-align: center; padding: 3rem 1rem; font-style: italic; color: var(--aged); }

/* â”€â”€ Error â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.error-box { background: rgba(139,26,26,.12); border: 1px solid var(--blood); border-radius: 3px; padding: 1.2rem 1.5rem; text-align: center; color: #e07070; font-style: italic; font-size: .9rem; max-width: 600px; margin: 0 auto; }
.error-box strong { display: block; font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .75rem; letter-spacing: .2em; color: var(--blood); margin-bottom: .4rem; }

/* â”€â”€ Archive Overlay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.archive-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.65); z-index: 100; opacity: 0; pointer-events: none; transition: opacity .3s; }
.archive-overlay.open { opacity: 1; pointer-events: all; }

/* â”€â”€ Archive Drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.archive-drawer { position: fixed; top: 0; right: 0; height: 100%; width: min(380px, 94vw); background: #120803; border-left: 2px solid var(--gold); z-index: 101; display: flex; flex-direction: column; transform: translateX(100%); transition: transform .32s cubic-bezier(.4,0,.2,1); box-shadow: -8px 0 40px rgba(0,0,0,.7); }
.archive-drawer.open { transform: translateX(0); }
.archive-drawer-head { padding: 1.6rem 1.5rem 1rem; border-bottom: 2px solid rgba(201,146,42,.3); display: flex; align-items: flex-start; justify-content: space-between; gap: 1rem; flex-shrink: 0; }
.archive-drawer-title { font-family: 'Cinzel Decorative', 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: 1.15rem; color: var(--gold); line-height: 1.2; text-shadow: 1px 1px 6px rgba(0,0,0,.8); }
.archive-drawer-sub { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .6rem; letter-spacing: .25em; color: var(--muted); text-transform: uppercase; margin-top: .3rem; }
.archive-close { background: none; border: 1px solid rgba(201,146,42,.3); color: var(--gold); font-size: 1.1rem; width: 2rem; height: 2rem; border-radius: 2px; cursor: pointer; display: flex; align-items: center; justify-content: center; flex-shrink: 0; transition: background .15s, color .15s; line-height: 1; }
.archive-close:hover { background: var(--gold); color: var(--ink); }
.archive-list { overflow-y: auto; flex: 1; padding: .5rem 0; }
.archive-list::-webkit-scrollbar { width: 5px; }
.archive-list::-webkit-scrollbar-track { background: transparent; }
.archive-list::-webkit-scrollbar-thumb { background: rgba(201,146,42,.3); border-radius: 3px; }
.archive-loading { padding: 2rem 1.5rem; font-style: italic; color: var(--muted); font-size: .85rem; text-align: center; }
.archive-entry { display: block; width: 100%; background: none; border: none; border-bottom: 1px solid rgba(201,146,42,.1); padding: .95rem 1.5rem; text-align: left; cursor: pointer; transition: background .15s; color: inherit; }
.archive-entry:hover { background: rgba(201,146,42,.08); }
.archive-entry.active { background: rgba(201,146,42,.12); border-left: 3px solid var(--gold); }
.archive-entry-label { font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .7rem; letter-spacing: .2em; color: var(--blood); text-transform: uppercase; margin-bottom: .2rem; }
.archive-entry-date { font-family: 'IM Fell English', Georgia, "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .95rem; color: var(--aged); }
.archive-entry.today .archive-entry-date { color: var(--gold); }
.archive-entry-today-badge { display: inline-block; font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; font-size: .55rem; letter-spacing: .2em; text-transform: uppercase; color: var(--ink); background: var(--gold); padding: .1rem .4rem; border-radius: 2px; margin-left: .5rem; vertical-align: middle; }
.archive-empty { padding: 2rem 1.5rem; font-style: italic; color: var(--muted); font-size: .85rem; text-align: center; }

/* â”€â”€ Footer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
footer { text-align: center; padding: 2rem 1rem; border-top: 3px double rgba(201,146,42,.3); margin-top: 3rem; font-style: italic; font-size: .78rem; color: var(--muted); letter-spacing: .05em; }
footer strong { color: var(--gold); font-style: normal; font-family: 'Cinzel', "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", serif; letter-spacing: .15em; }
footer a { color: var(--gold); text-decoration: none; border-bottom: 1px dotted rgba(201,146,42,.55); }
footer a:hover { color: var(--parchment); border-bottom-color: var(--gold); }
</style>
</head>
<body>

<!-- Archive overlay (click to close) -->
<div class="archive-overlay" id="archive-overlay" aria-hidden="true"></div>

<!-- Story modal overlay (single-story preview) -->
<div class="story-modal-overlay" id="story-modal-overlay" aria-hidden="true"></div>
<div class="story-modal" id="story-modal" role="dialog" aria-label="Story preview" aria-modal="true">
  <div class="story-modal-panel" id="story-modal-panel">
    <div class="story-modal-top">
      <div>
        <div class="story-modal-title" id="story-modal-title">â€”</div>
        <div class="story-modal-sub" id="story-modal-sub">â€”</div>
      </div>
      <button class="story-modal-close" id="story-modal-close" aria-label="Close story">âœ•</button>
    </div>
    <div class="story-modal-actions" id="story-modal-actions"></div>
    <div class="story-entities" id="story-modal-entities" style="display:none;" aria-label="Entities in this story"></div>
    <hr class="story-divider" />
    <div class="story-modal-text" id="story-modal-text"></div>
  </div>
</div>

<!-- Codex entry modal (for entity links inside story text) -->
<div class="story-modal-overlay" id="codex-modal-overlay" aria-hidden="true"></div>
<div class="story-modal" id="codex-modal" role="dialog" aria-label="Codex entry" aria-modal="true">
  <div class="story-modal-panel" id="codex-modal-panel">
    <div class="story-modal-top">
      <div>
        <div class="story-modal-title" id="codex-modal-title">â€”</div>
        <div class="story-modal-sub" id="codex-modal-sub">â€”</div>
      </div>
      <button class="story-modal-close" id="codex-modal-close" aria-label="Close codex entry">âœ•</button>
    </div>
    <div class="story-modal-actions" id="codex-modal-actions"></div>
    <hr class="story-divider" />
    <div class="codex-modal-body" id="codex-modal-body"></div>
  </div>
</div>

<!-- Archive drawer -->
<div class="archive-drawer" id="archive-drawer" role="dialog" aria-label="Archive of past issues">
  <div class="archive-drawer-head">
    <div>
      <div class="archive-drawer-title">The Vault of Tales</div>
      <div class="archive-drawer-sub">Past Issues of The Daily Blade</div>
    </div>
    <button class="archive-close" id="archive-close" aria-label="Close archive">âœ•</button>
  </div>
  <div class="archive-list" id="archive-list">
    <div class="archive-loading"><span class="spinner"></span> Consulting the grimoireâ€¦</div>
  </div>
</div>

<div class="page-wrap">
  <header class="masthead">
    <p class="masthead-eyebrow">Est. Anno Domini MMXXVI â€” Daily Edition</p>
    <h1 class="masthead-title">The Daily Blade</h1>
    <p class="masthead-sub">Ten Tales of Sword &amp; Sorcery â€” Fresh Each Dawn</p>
    <p class="masthead-date" id="today-date"></p>
  </header>

  <!-- â”€â”€ Main Nav â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <nav class="main-nav" aria-label="Main sections">
    <button class="main-tab active" id="tab-tales" aria-selected="true">âš” Tales</button>
    <button class="main-tab" id="tab-characters" aria-selected="false">ğŸ“– Codex</button>
    <div class="main-nav-right">
      <button class="btn" id="archive-btn" aria-label="Browse the archive">ğŸ“œ Archive</button>
    </div>
  </nav>

  <!-- â”€â”€ Tales View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="tales-view">
    <!-- Genre filter bar -->
    <div class="genre-bar" id="genre-bar" role="group" aria-label="Filter by genre">
    </div>
    <div class="controls">
      <span class="controls-left" id="story-count-label">â€” Loading today's talesâ€¦ â€”</span>
    </div>
    <div id="status-msg">
      <span class="spinner"></span>
      <em>Summoning the storiesâ€¦</em>
    </div>
    <div class="story-grid" id="story-grid" style="display:none;"></div>
  </div>

  <!-- â”€â”€ Codex View â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="char-view">
    <!-- Entity type filter pills -->
    <div class="codex-filter-bar" id="codex-filter-bar" role="group" aria-label="Filter codex by type">
      <button class="codex-filter-btn active" data-type="all">All Entries</button>
      <button class="codex-filter-btn" data-type="characters">âš” Characters</button>
      <button class="codex-filter-btn" data-type="places">ğŸ° Places</button>
      <button class="codex-filter-btn" data-type="hemispheres">ğŸŒ— Hemispheres</button>
      <button class="codex-filter-btn" data-type="continents">ğŸ§­ Continents</button>
      <button class="codex-filter-btn" data-type="subcontinents">ğŸ—º Subcontinents</button>
      <button class="codex-filter-btn" data-type="realms">ğŸ› Realms</button>
      <button class="codex-filter-btn" data-type="provinces">ğŸ· Provinces</button>
      <button class="codex-filter-btn" data-type="regions">ğŸ—º Regions</button>
      <button class="codex-filter-btn" data-type="districts">ğŸ§± Districts</button>
      <button class="codex-filter-btn" data-type="events">âš¡ Events</button>
      <button class="codex-filter-btn" data-type="weapons">ğŸ—¡ Weapons</button>
      <button class="codex-filter-btn" data-type="artifacts">ğŸ’ Artifacts</button>
      <button class="codex-filter-btn" data-type="factions">ğŸ§™ Factions</button>
      <button class="codex-filter-btn" data-type="lore">ğŸ“œ Lore</button>
      <button class="codex-filter-btn" data-type="flora_fauna">ğŸŒ¿ Flora & Fauna</button>
      <button class="codex-filter-btn" data-type="magic">âœ¨ Magic</button>
      <button class="codex-filter-btn" data-type="relics">ğŸ’€ Relics</button>
      <button class="codex-filter-btn" data-type="substances">âš— Substances</button>
    </div>
    <div class="controls" style="margin-top:.5rem;">
      <span class="controls-left" id="char-count-label">â€” The Codex of Known Lore â€”</span>
      <div class="controls-right" id="codex-organize-controls" style="display:none;">
        <span class="codex-organize-label">Organize</span>
        <select class="codex-organize-select" id="codex-organize-mode" aria-label="Organize codex entries">
          <option value="default">Default</option>
          <option value="label">By Label</option>
        </select>
        <select class="codex-organize-select" id="codex-organize-label" aria-label="Filter codex by label" style="display:none;">
          <option value="all">All Labels</option>
        </select>
      </div>
    </div>
    <div id="char-status-msg" class="char-status">
      <span class="spinner"></span>
      <em>Consulting the lore scrollsâ€¦</em>
    </div>
    <div class="char-grid" id="char-grid" style="display:none;"></div>
  </div>

  <footer>
    <strong>The Daily Blade</strong> &nbsp;Â·&nbsp; Stories generated by <strong>Claude</strong> AI &nbsp;Â·&nbsp; New tales conjured each dawn &nbsp;Â·&nbsp; All characters, sorceries &amp; kingdoms are entirely fictitious &nbsp;Â·&nbsp; Dedicated to the public domain under <a href="https://creativecommons.org/publicdomain/zero/1.0/" rel="license">CC0 1.0</a>
  </footer>
</div>

<script>
// â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const STORIES_URL    = './stories.json';
const ARCHIVE_IDX_URL = './archive/index.json';
const ARCHIVE_URL    = (date) => `./archive/${date}.json`;
const CODEX_URL      = './codex.json';

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentDate     = null;
let archiveLoaded   = false;
let currentTab      = 'tales';
let activeGenre     = 'all';
let codexLoaded     = false;
let activeCodexType = 'all';

let activeCodexOrganizeMode = 'default';
let activeCodexOrganizeLabel = 'all';
let CODEX_DATA_CACHE = null;

// Entity linking (clickable names inside story text)
let codexDataLoaded = false;
let CODEX_ENTITY_INDEX = new Map(); // key (normalized lower) -> [{ type, obj }]
let CODEX_ENTITY_REGEX = null;
let CODEX_DATA_PROMISE = null;

// Cache for day story payloads used by the story modal.
// key: date string (YYYY-MM-DD), value: { date, stories: [...] }
const STORY_DAY_CACHE = new Map();

// Modal navigation state for multi-appearance entities.
let STORY_MODAL_APPEARANCES = [];
let STORY_MODAL_INDEX = 0;

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function todayStr() { return new Date().toISOString().slice(0, 10); }
function formatDate(isoStr) {
  const d = new Date(isoStr + 'T12:00:00');
  return d.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
}
function stripControlChars(str) {
  // Remove non-printable control characters that can render as tofu/rectangles.
  // Keep tab/newline for formatting.
  return String(str || '')
    .replace(/\r\n?/g, '\n')
    .replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, '');
}
function escHtml(str) {
  return stripControlChars(String(str))
    .replace(/[\uFE0E\uFE0F]/g, '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
}

function splitMultiLabels(value) {
  if (!value) return [];
  const raw = String(value);
  return raw
    .split(/\s*(?:\/|\||;|,|&|\band\b)\s*/i)
    .map(s => s.trim())
    .filter(Boolean);
}

function normalizeEntityKey(name) {
  return String(name || '')
    .trim()
    .toLowerCase()
    .replace(/[\u2018\u2019]/g, "'")
    .replace(/\s+/g, ' ');
}

function stripTrailingParenthetical(name) {
  // Remove trailing qualifiers like " (as Region)" that can break matching.
  // Only strips a parenthetical at the end.
  const s = String(name || '').trim();
  return s.replace(/\s*\([^)]*\)\s*$/g, '').trim();
}

function escapeRegexPiece(str) {
  // Escape for literal matching, but treat apostrophes as either straight or curly.
  const s = String(str || '');
  let out = '';
  for (const ch of s) {
    if (ch === "'" || ch === '\u2019' || ch === '\u2018') {
      out += "(?:'|\u2019|\u2018)";
      continue;
    }
    // Escape regex metacharacters
    if (/[$()*+.?[\\\]^{|}]/.test(ch)) out += '\\' + ch;
    else out += ch;
  }
  return out;
}

function codexTypeLabel(type) {
  return {
    characters: 'Characters',
    places: 'Places',
    hemispheres: 'Hemispheres',
    continents: 'Continents',
    subcontinents: 'Subcontinents',
    realms: 'Realms',
    provinces: 'Provinces',
    districts: 'Districts',
    regions: 'Regions',
    events: 'Events',
    weapons: 'Weapons',
    artifacts: 'Artifacts',
    factions: 'Factions',
    lore: 'Lore',
    flora_fauna: 'Flora & Fauna',
    magic: 'Magic',
    relics: 'Relics',
    substances: 'Substances',
  }[type] || String(type || 'Entry');
}

function badgeClassForEntityType(type) {
  return {
    characters: 'badge-role',
    places: 'badge-place',
    hemispheres: 'badge-region',
    continents: 'badge-region',
    subcontinents: 'badge-region',
    realms: 'badge-region',
    provinces: 'badge-region',
    districts: 'badge-region',
    regions: 'badge-region',
    events: 'badge-event',
    weapons: 'badge-weapon',
    artifacts: 'badge-artifact',
    factions: 'badge-faction',
    lore: 'badge-lore',
    flora_fauna: 'badge-flora',
    magic: 'badge-magic',
    relics: 'badge-relic',
    substances: 'badge-substance',
  }[type] || 'badge-status-default';
}

function buildCodexEntityIndex(data) {
  const d = data || CODEX_DATA_CACHE;
  if (!d) return;

  const categories = [
    'characters','places','hemispheres','continents','subcontinents','realms','provinces','regions','districts',
    'events','weapons','artifacts','factions','lore','flora_fauna','magic','relics','substances'
  ];
  const index = new Map();
  const names = [];

  const addToIndex = (key, type, obj) => {
    if (!key || key.length < 3) return;
    if (!index.has(key)) index.set(key, []);
    index.get(key).push({ type, obj });
  };

  categories.forEach(type => {
    const arr = Array.isArray(d[type]) ? d[type] : [];
    arr.forEach(obj => {
      const nm = (obj && obj.name) ? String(obj.name).trim() : '';
      if (!nm) return;
      const key = normalizeEntityKey(nm);
      if (!key) return;
      addToIndex(key, type, obj);

      // Alias without trailing parenthetical qualifiers.
      // Example: "Sunken Marches (as Region)" -> "Sunken Marches"
      const base = stripTrailingParenthetical(nm);
      const baseKey = normalizeEntityKey(base);
      if (baseKey && baseKey !== key) {
        addToIndex(baseKey, type, obj);
      }

      // Alias without leading article for easier matching in prose.
      if (key.startsWith('the ')) {
        const alias = key.slice(4).trim();
        addToIndex(alias, type, obj);
      }

      if (baseKey && baseKey !== key && baseKey.startsWith('the ')) {
        const alias = baseKey.slice(4).trim();
        addToIndex(alias, type, obj);
      }

      // Alias for epithets: "Velgrim the Terrible" -> "Velgrim"
      const theIdx = key.indexOf(' the ');
      if (theIdx > 2) {
        const alias = key.slice(0, theIdx).trim();
        addToIndex(alias, type, obj);
      }

      if (baseKey && baseKey !== key) {
        const theIdx2 = baseKey.indexOf(' the ');
        if (theIdx2 > 2) {
          const alias = baseKey.slice(0, theIdx2).trim();
          addToIndex(alias, type, obj);
        }
      }

      // Alias before comma: "Name, Title" -> "Name"
      const commaIdx = key.indexOf(',');
      if (commaIdx > 2) {
        const alias = key.slice(0, commaIdx).trim();
        addToIndex(alias, type, obj);
      }

      if (baseKey && baseKey !== key) {
        const commaIdx2 = baseKey.indexOf(',');
        if (commaIdx2 > 2) {
          const alias = baseKey.slice(0, commaIdx2).trim();
          addToIndex(alias, type, obj);
        }
      }
    });
  });

  index.forEach((_, key) => names.push(key));
  names.sort((a, b) => b.length - a.length);

  // Build one big regex to find any entity name, with optional leading "the".
  // Uses Unicode property escapes for robust word-ish boundaries.
  const alts = names
    .filter(n => n.length >= 3)
    .map(n => escapeRegexPiece(n))
    .join('|');
  CODEX_ENTITY_INDEX = index;
  if (!alts) {
    CODEX_ENTITY_REGEX = null;
    return;
  }

  // Prefer Unicode-aware boundaries; fall back for older browsers.
  try {
    CODEX_ENTITY_REGEX = new RegExp(`(^|[^\\p{L}\\p{N}])((?:the\\s+)?)(${alts})(?=$|[^\\p{L}\\p{N}])`, 'giu');
  } catch (e) {
    CODEX_ENTITY_REGEX = new RegExp(`(^|[^A-Za-z0-9])((?:the\\s+)?)(${alts})(?=$|[^A-Za-z0-9])`, 'gi');
  }
}

async function ensureCodexDataLoaded() {
  if (codexDataLoaded && CODEX_DATA_CACHE) return CODEX_DATA_CACHE;
  if (CODEX_DATA_PROMISE) return CODEX_DATA_PROMISE;
  CODEX_DATA_PROMISE = (async () => {
    const res = await fetch(CODEX_URL + '?t=' + Date.now());
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    CODEX_DATA_CACHE = data;
    codexDataLoaded = true;
    buildCodexEntityIndex(data);
    return data;
  })();
  try {
    return await CODEX_DATA_PROMISE;
  } finally {
    CODEX_DATA_PROMISE = null;
  }
}

function extractEntitiesFromText(rawText) {
  const text = fixMojibake(rawText || '');
  if (!CODEX_ENTITY_REGEX || !CODEX_ENTITY_INDEX || CODEX_ENTITY_INDEX.size === 0) return new Map();

  const found = new Map(); // type -> Map(nameKey -> { key, type, name })
  CODEX_ENTITY_REGEX.lastIndex = 0;
  let m;
  while ((m = CODEX_ENTITY_REGEX.exec(text)) !== null) {
    const namePart = m[3] || '';
    const key = normalizeEntityKey(namePart);
    const matches = CODEX_ENTITY_INDEX.get(key) || [];
    matches.forEach(({ type, obj }) => {
      let canonicalName = (obj && obj.name) ? String(obj.name).trim() : String(namePart).trim();
      // If codex entry has a trailing qualifier ("Name (as Region)"), prefer the
      // story-surface name for display, while still linking to the same entry.
      const base = stripTrailingParenthetical(canonicalName);
      if (base && base !== canonicalName) {
        const baseKey = normalizeEntityKey(base);
        if (baseKey && baseKey === key) canonicalName = base;
      }
      if (!canonicalName) return;
      const canonKey = normalizeEntityKey(canonicalName);
      if (!found.has(type)) found.set(type, new Map());
      const bucket = found.get(type);
      if (!bucket.has(canonKey)) bucket.set(canonKey, { key: canonKey, type, name: canonicalName });
    });
  }
  return found;
}

function renderEntityBadges(containerEl, entitiesByType) {
  if (!containerEl) return;
  if (!entitiesByType || entitiesByType.size === 0) {
    containerEl.innerHTML = '';
    containerEl.style.display = 'none';
    return;
  }

  const typeOrder = [
    'characters', 'places', 'events', 'factions', 'magic', 'relics', 'artifacts', 'weapons', 'lore', 'flora_fauna', 'substances',
    'regions', 'districts', 'provinces', 'realms', 'subcontinents', 'continents', 'hemispheres'
  ];
  const types = Array.from(entitiesByType.keys());
  types.sort((a, b) => {
    const ai = typeOrder.indexOf(a);
    const bi = typeOrder.indexOf(b);
    if (ai >= 0 && bi >= 0) return ai - bi;
    if (ai >= 0) return -1;
    if (bi >= 0) return 1;
    return String(a).localeCompare(String(b));
  });

  const rows = [];
  types.forEach(type => {
    const bucket = entitiesByType.get(type);
    const list = bucket ? Array.from(bucket.values()) : [];
    if (list.length === 0) return;
    list.sort((x, y) => String(x.name).toLowerCase().localeCompare(String(y.name).toLowerCase()));
    const badges = list.map(e => (
      `<button type="button" class="badge entity-badge ${badgeClassForEntityType(type)}" data-entity-key="${escHtml(e.key)}" data-entity-type="${escHtml(type)}">${escHtml(e.name)}</button>`
    )).join('');
    rows.push(`
      <div class="story-entities-row">
        <span class="story-entities-label">${escHtml(codexTypeLabel(type))}</span>
        <div class="story-entities-badges">${badges}</div>
      </div>
    `);
  });

  containerEl.innerHTML = rows.join('');
  containerEl.style.display = rows.length ? '' : 'none';
}

function enhanceStoryEntityBadges() {
  if (!CODEX_ENTITY_REGEX) return;

  document.querySelectorAll('.story-card').forEach(card => {
    const p = card.querySelector('.story-text[data-raw-text]');
    const box = card.querySelector('.story-entities');
    if (!p || !box) return;
    if (box.dataset.enhanced === '1') return;
    const entities = extractEntitiesFromText(p.dataset.rawText || '');
    renderEntityBadges(box, entities);
    box.dataset.enhanced = '1';
  });

  const modalBox = document.getElementById('story-modal-entities');
  const modalText = document.getElementById('story-modal-text');
  if (modalBox && modalText && modalText.dataset && modalText.dataset.rawText) {
    const entities = extractEntitiesFromText(modalText.dataset.rawText || '');
    renderEntityBadges(modalBox, entities);
  }
}

function isCodexModalOpen() {
  return document.getElementById('codex-modal').classList.contains('open');
}

function closeCodexModal() {
  document.getElementById('codex-modal-overlay').classList.remove('open');
  document.getElementById('codex-modal').classList.remove('open');
  document.getElementById('codex-modal-overlay').setAttribute('aria-hidden', 'true');
  document.getElementById('codex-modal-title').textContent = 'â€”';
  document.getElementById('codex-modal-sub').textContent = 'â€”';
  document.getElementById('codex-modal-actions').innerHTML = '';
  document.getElementById('codex-modal-body').innerHTML = '';
}

function openCodexModalSkeleton() {
  document.getElementById('codex-modal-overlay').classList.add('open');
  document.getElementById('codex-modal').classList.add('open');
  document.getElementById('codex-modal-overlay').setAttribute('aria-hidden', 'false');
}

function renderCodexEntryModalBody(type, obj, key) {
  const titleEl = document.getElementById('codex-modal-title');
  const subEl = document.getElementById('codex-modal-sub');
  const bodyEl = document.getElementById('codex-modal-body');
  titleEl.textContent = (obj && obj.name) ? obj.name : (key || 'â€”');
  subEl.textContent = codexTypeLabel(type);

  // Prefer rendering the *exact* Codex card by cloning it from the Codex view.
  const wantKey = normalizeEntityKey(obj && obj.name ? obj.name : key);
  const selector = `.codex-card[data-entity-type="${CSS.escape(type)}"][data-name-sort="${CSS.escape(wantKey)}"]`;
  const source = document.querySelector(selector);
  if (source) {
    bodyEl.innerHTML = '';
    const clone = source.cloneNode(true);
    clone.classList.remove('hidden');
    clone.classList.remove('hidden-org');
    clone.classList.remove('codex-flash');
    bodyEl.appendChild(clone);
    attachStoryLinkListeners(clone);
  } else {
    // Fallback: lightweight details when Codex hasn't rendered yet.
    const tokens = _primaryLabelTokensForEntity(type, obj);
    const primary = (tokens && tokens.length) ? tokens[0] : 'Unknown';
    const appearances = obj && typeof obj.appearances === 'number'
      ? (obj.appearances > 1 ? `${obj.appearances} appearances` : 'First appearance')
      : (obj && obj.first_story ? 'First appearance' : 'Entry');
    bodyEl.innerHTML = `
      <div class="codex-card-header">
        ${obj && obj.tagline ? `<div class="codex-card-tagline">${escHtml(obj.tagline)}</div>` : ''}
        <div class="codex-card-badges">
          <span class="badge ${badgeClassForEntityType(type)}">${escHtml(primary)}</span>
          ${obj && obj.status ? `<span class="badge ${statusBadgeClass(obj.status)}">${escHtml(obj.status)}</span>` : ''}
        </div>
      </div>
      <hr class="codex-divider" />
      <div class="codex-body">${escHtml((obj && (obj.description || obj.bio || obj.outcome)) ? (obj.description || obj.bio || obj.outcome) : '')}</div>
      ${buildMostSpecificLocationLine(obj)}
      ${buildEntityParentChain(obj)}
      <div class="codex-meta">
        <span>${escHtml(appearances)}</span>
        ${obj && obj.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(obj.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(obj ? obj.story_appearances : null, obj ? obj.first_story : '', obj ? obj.first_date : '')}
    `;
    attachStoryLinkListeners(document.getElementById('codex-modal-panel'));
  }

  const actions = document.getElementById('codex-modal-actions');
  actions.innerHTML = '';
  const viewBtn = document.createElement('button');
  viewBtn.className = 'btn btn-icon';
  viewBtn.textContent = 'View in Codex';
  viewBtn.addEventListener('click', async () => {
    closeCodexModal();
    switchTab('characters');
    await loadCodex(false);
    if (type) applyCodexFilter(type);
    const card = document.querySelector(`.codex-card[data-entity-type="${CSS.escape(type)}"][data-name-sort="${CSS.escape(normalizeEntityKey(obj && obj.name ? obj.name : key))}"]`);
    if (card) {
      card.classList.add('codex-flash');
      card.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => card.classList.remove('codex-flash'), 1200);
    }
  });
  actions.appendChild(viewBtn);

  // Enable story preview buttons inside the modal.
  attachStoryLinkListeners(document.getElementById('codex-modal-panel'));
}

async function openCodexEntryByKey(key, typeHint = '') {
  openCodexModalSkeleton();
  document.getElementById('codex-modal-title').textContent = 'Consulting the lore scrollsâ€¦';
  document.getElementById('codex-modal-sub').textContent = 'â€”';
  document.getElementById('codex-modal-actions').innerHTML = '';
  document.getElementById('codex-modal-body').innerHTML = '<span class="spinner"></span><em>Searching the Codexâ€¦</em>';

  try {
    await ensureCodexDataLoaded();
    // Ensure the Codex view has rendered, so we can clone the exact card markup.
    await loadCodex(false);
    const matches = CODEX_ENTITY_INDEX.get(key) || [];
    if (matches.length === 0) {
      document.getElementById('codex-modal-title').textContent = 'Not found';
      document.getElementById('codex-modal-sub').textContent = 'â€”';
      document.getElementById('codex-modal-body').innerHTML = `<div class="error-box"><strong>âš  Entry Missing</strong> The Codex has no entry for <em>${escHtml(key)}</em> yet.</div>`;
      return;
    }

    let pick = null;
    if (typeHint) {
      pick = matches.find(m => m.type === typeHint) || null;
    }

    if (!pick && matches.length === 1) {
      pick = matches[0];
    }

    if (!pick) {
      document.getElementById('codex-modal-title').textContent = 'Choose an entry';
      document.getElementById('codex-modal-sub').textContent = key;
      const bodyEl = document.getElementById('codex-modal-body');
      const options = matches.map(m => `<button type="button" class="codex-story-link" data-choose-type="${escHtml(m.type)}">${escHtml(codexTypeLabel(m.type))}</button>`).join('');
      bodyEl.innerHTML = `<div class="codex-body" style="margin-bottom:.6rem">Multiple entries share this name. Which did you mean?</div><div class="codex-story-links"><span class="codex-story-links-label">Open</span>${options}</div>`;
      bodyEl.querySelectorAll('button[data-choose-type]').forEach(btn => {
        btn.addEventListener('click', () => {
          openCodexEntryByKey(key, btn.dataset.chooseType || '');
        });
      });
      return;
    }

    renderCodexEntryModalBody(pick.type, pick.obj, key);
  } catch (err) {
    console.error(err);
    document.getElementById('codex-modal-title').textContent = 'âš  Could not open entry';
    document.getElementById('codex-modal-sub').textContent = 'â€”';
    document.getElementById('codex-modal-actions').innerHTML = '';
    document.getElementById('codex-modal-body').textContent = (err && err.message) ? err.message : String(err);
  }
}

function _primaryLabelTokensForEntity(type, obj) {
  const o = obj || {};
  const pick = (v, fallback) => {
    const tokens = splitMultiLabels(v);
    if (tokens.length) return tokens;
    if (fallback) return [fallback];
    return ['Unknown'];
  };

  if (type === 'characters') return pick(o.role, 'Unknown');
  if (type === 'places') return pick(o.place_type, 'Location');
  if (type === 'events') return pick(o.event_type, 'Event');
  if (type === 'weapons') return pick(o.weapon_type, 'Weapon');
  if (type === 'artifacts') return pick(o.artifact_type, 'Artifact');
  if (type === 'factions') return pick(o.alignment, 'Faction');
  if (type === 'lore') return pick(o.category, 'Lore');
  if (type === 'flora_fauna') return pick(o.type, 'Flora');
  if (type === 'magic') return pick(o.type, 'Magic');
  if (type === 'relics') return pick(o.origin, 'Relic');
  if (type === 'substances') return pick(o.rarity, 'Substance');
  if (['hemispheres','continents','subcontinents','realms','provinces','districts','regions'].includes(type)) {
    return pick(o.climate, type.slice(0,1).toUpperCase() + type.slice(1, -1));
  }
  return ['Unknown'];
}

function stampCodexCardMeta(card, entityType, name, primaryLabelTokens) {
  const nm = (name || '').trim();
  card.dataset.entityType = entityType;
  card.dataset.nameSort = nm.toLowerCase();
  const tokens = Array.isArray(primaryLabelTokens) ? primaryLabelTokens : splitMultiLabels(primaryLabelTokens);
  card.dataset.primaryLabels = (tokens && tokens.length ? tokens : ['Unknown']).join('|');
}

function visibleCodexCards() {
  return Array.from(document.querySelectorAll('.codex-card'))
    .filter(c => !c.classList.contains('hidden') && !c.classList.contains('hidden-org'));
}

function updateCodexCountLabel() {
  const label = document.getElementById('char-count-label');
  const visible = visibleCodexCards().length;
  if (activeCodexType === 'all') {
    label.textContent = `â€” ${visible} Entr${visible !== 1 ? 'ies' : 'y'} in the Codex â€”`;
    return;
  }
  const typeLabel = {
    characters: 'Characters',
    places: 'Places',
    hemispheres: 'Hemispheres',
    continents: 'Continents',
    subcontinents: 'Subcontinents',
    realms: 'Realms',
    provinces: 'Provinces',
    districts: 'Districts',
    regions: 'Regions',
    events: 'Events',
    weapons: 'Weapons',
    artifacts: 'Artifacts',
    factions: 'Factions',
    lore: 'Lore',
    flora_fauna: 'Flora & Fauna',
    magic: 'Magic',
    relics: 'Relics',
    substances: 'Substances',
  }[activeCodexType] || activeCodexType;
  label.textContent = `â€” ${visible} Known ${typeLabel} â€”`;
}

function clearCodexGroupHeaders() {
  document.querySelectorAll('.codex-group-header').forEach(el => el.remove());
}

function applyCodexOrganization() {
  const grid = document.getElementById('char-grid');
  if (!grid) return;

  clearCodexGroupHeaders();
  document.querySelectorAll('.codex-card').forEach(c => c.classList.remove('hidden-org'));

  const controls = document.getElementById('codex-organize-controls');
  const labelSelect = document.getElementById('codex-organize-label');
  if (controls) controls.style.display = (codexLoaded ? '' : 'none');

  if (!codexLoaded) return;

  if (activeCodexOrganizeMode !== 'label') {
    if (labelSelect) labelSelect.style.display = 'none';
    updateCodexCountLabel();
    return;
  }

  const base = Array.from(grid.querySelectorAll('.codex-card')).filter(c => !c.classList.contains('hidden'));

  // Special case: when viewing "All Entries", grouping-by-label isn't meaningful.
  // In this case we interpret "By Label" as "By Category" and hide the label filter.
  const groupByCategory = (activeCodexType === 'all');
  if (labelSelect) labelSelect.style.display = groupByCategory ? 'none' : '';

  if (!groupByCategory && activeCodexOrganizeLabel && activeCodexOrganizeLabel !== 'all') {
    const needle = activeCodexOrganizeLabel.toLowerCase();
    base.forEach(c => {
      const tokens = String(c.dataset.primaryLabels || '').split('|').map(s => s.trim().toLowerCase()).filter(Boolean);
      if (!tokens.includes(needle)) c.classList.add('hidden-org');
    });
  }

  const cards = base.filter(c => !c.classList.contains('hidden-org'));
  const groups = new Map();
  cards.forEach(c => {
    let key = 'Unknown';
    if (groupByCategory) {
      key = String(c.dataset.entityType || 'Unknown');
    } else {
      const tokens = String(c.dataset.primaryLabels || '').split('|').map(s => s.trim()).filter(Boolean);
      key = (tokens[0] || 'Unknown').trim() || 'Unknown';
    }
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(c);
  });

  const typeLabel = {
    characters: 'Characters',
    places: 'Places',
    hemispheres: 'Hemispheres',
    continents: 'Continents',
    subcontinents: 'Subcontinents',
    realms: 'Realms',
    provinces: 'Provinces',
    regions: 'Regions',
    districts: 'Districts',
    events: 'Events',
    weapons: 'Weapons',
    artifacts: 'Artifacts',
    factions: 'Factions',
    lore: 'Lore',
    flora_fauna: 'Flora & Fauna',
    magic: 'Magic',
    relics: 'Relics',
    substances: 'Substances',
  };

  const groupKeys = Array.from(groups.keys()).sort((a, b) => {
    if (groupByCategory) {
      const aa = (typeLabel[a] || a).toLowerCase();
      const bb = (typeLabel[b] || b).toLowerCase();
      return aa.localeCompare(bb);
    }
    const aa = a.toLowerCase();
    const bb = b.toLowerCase();
    if (aa === 'unknown') return 1;
    if (bb === 'unknown') return -1;
    return aa.localeCompare(bb);
  });

  // Rebuild visible card order with headers.
  const frag = document.createDocumentFragment();
  groupKeys.forEach(k => {
    const arr = groups.get(k) || [];
    arr.sort((x, y) => String(x.dataset.nameSort || '').localeCompare(String(y.dataset.nameSort || '')));
    const header = document.createElement('div');
    header.className = 'codex-group-header';
    const label = groupByCategory ? (typeLabel[k] || k) : k;
    header.innerHTML = `<div class="codex-group-title">${escHtml(label)}</div><div class="codex-group-count">${arr.length} entr${arr.length !== 1 ? 'ies' : 'y'}</div>`;
    frag.appendChild(header);
    arr.forEach(c => frag.appendChild(c));
  });

  // Append hidden (by type) cards after, preserving them in DOM.
  const hiddenCards = Array.from(grid.querySelectorAll('.codex-card')).filter(c => c.classList.contains('hidden') || c.classList.contains('hidden-org'));
  hiddenCards.forEach(c => frag.appendChild(c));
  grid.innerHTML = '';
  grid.appendChild(frag);

  updateCodexCountLabel();
}

function refreshCodexLabelOptions() {
  const labelSelect = document.getElementById('codex-organize-label');
  if (!labelSelect) return;
  const cards = Array.from(document.querySelectorAll('.codex-card')).filter(c => !c.classList.contains('hidden'));
  const tokens = new Set();
  cards.forEach(c => {
    String(c.dataset.primaryLabels || '')
      .split('|')
      .map(s => s.trim())
      .filter(Boolean)
      .forEach(t => tokens.add(t));
  });
  const sorted = Array.from(tokens).sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
  labelSelect.innerHTML = '<option value="all">All Labels</option>' + sorted.map(t => `<option value="${escHtml(t)}">${escHtml(t)}</option>`).join('');
  if (!sorted.some(t => t.toLowerCase() === String(activeCodexOrganizeLabel || '').toLowerCase())) {
    activeCodexOrganizeLabel = 'all';
  }
  labelSelect.value = activeCodexOrganizeLabel;
}
function setStatus(html) {
  const msg  = document.getElementById('status-msg');
  const grid = document.getElementById('story-grid');
  msg.innerHTML = html;
  msg.style.display = '';
  grid.style.display = 'none';
}

function hostingHintHtml() {
  const proto = window.location.protocol;
  const host = window.location.hostname;
  const path = window.location.pathname || '';

  if (proto === 'file:') {
    return `Tip: this page must be served over HTTP (not <code>file://</code>). Try <code>python3 -m http.server 8008</code> and open <code>http://localhost:8008/index.html</code>.`;
  }

  // GitHub's repo file viewer (blob URLs) won't run the app properly.
  if (host === 'github.com' && path.includes('/blob/')) {
    return `Tip: the GitHub file viewer doesn't run this app. Use GitHub Pages, or run it locally via <code>python3 -m http.server 8008</code>.`;
  }

  return '';
}

function errorBoxHtml(title, message) {
  const hint = hostingHintHtml();
  const hintHtml = hint ? `<div style="margin-top:.6rem;color:var(--muted);font-size:.82rem">${hint}</div>` : '';
  return `<div class="error-box"><strong>${escHtml(title)}</strong> ${escHtml(message)}${hintHtml}</div>`;
}

// â”€â”€ Genre Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyGenreFilter(genre) {
  activeGenre = genre;
  document.querySelectorAll('.genre-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.genre === genre);
  });
  const cards = document.querySelectorAll('.story-card');
  let visible = 0;
  cards.forEach(card => {
    const match = genre === 'all' || card.dataset.subgenre === genre;
    card.classList.toggle('hidden', !match);
    if (match) visible++;
  });
  const noRes = document.getElementById('genre-no-results');
  if (noRes) noRes.remove();
  if (visible === 0 && cards.length > 0) {
    const el = document.createElement('p');
    el.id = 'genre-no-results';
    el.className = 'no-results';
    el.innerHTML = `<em>No tales of that kind today. Return on another dawn, or view all tales.</em>`;
    document.getElementById('story-grid').appendChild(el);
  }
  const label = document.getElementById('story-count-label');
  if (genre === 'all') {
    label.textContent = currentDate
      ? `â€” Tales from ${formatDate(currentDate)} â€”`
      : 'â€” Ten tales of blood and glory, conjured this very dawn â€”';
  } else {
    label.textContent = `â€” ${visible} tale${visible !== 1 ? 's' : ''} of ${genre} â€”`;
  }
}

// â”€â”€ Codex Filter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyCodexFilter(type) {
  activeCodexType = type;
  document.querySelectorAll('.codex-filter-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.type === type);
  });
  const cards = document.querySelectorAll('.codex-card');
  cards.forEach(card => {
    const match = type === 'all' || card.dataset.entityType === type;
    card.classList.toggle('hidden', !match);
  });

  refreshCodexLabelOptions();
  applyCodexOrganization();
}

// â”€â”€ Fix UTF-8 mojibake â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fixMojibake(str) {
  try {
    const bytes = new Uint8Array(str.length);
    for (let i = 0; i < str.length; i++) bytes[i] = str.charCodeAt(i) & 0xff;
    return stripControlChars(new TextDecoder('utf-8', { fatal: true }).decode(bytes)).replace(/[\uFE0E\uFE0F]/g, '');
  } catch (e) { return stripControlChars(String(str || '')).replace(/[\uFE0E\uFE0F]/g, ''); }
}

// â”€â”€ Render Stories â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderStories(data) {
  document.getElementById('status-msg').style.display = 'none';
  const grid = document.getElementById('story-grid');
  grid.innerHTML = '';
  grid.style.display = '';
  data.stories.forEach((s, i) => {
    const card = document.createElement('article');
    card.className = 'story-card';
    card.dataset.subgenre = s.subgenre || '';
    card.dataset.title = String(s.title || '').trim().toLowerCase();
    const subgenreEsc = escHtml(s.subgenre || 'Sword & Sorcery');
    card.innerHTML = `
      <p class="story-number">Tale ${String(i + 1).padStart(2, '0')} of ${data.stories.length}</p>
      <span class="story-tag" title="Filter by this genre" data-genre="${subgenreEsc}">${subgenreEsc}</span>
      <h2 class="story-title">${escHtml(s.title || 'Untitled')}</h2>
      <hr class="story-divider" />
      <p class="story-text"></p>
      <div class="story-entities" style="display:none;" aria-label="Entities in this story"></div>
    `;

    const rawText = fixMojibake(s.text || '');
    const p = card.querySelector('.story-text');
    p.dataset.rawText = rawText;
    p.textContent = rawText;

    card.querySelector('.story-tag').addEventListener('click', () => {
      applyGenreFilter(s.subgenre || 'all');
    });
    grid.appendChild(card);
  });

  // Fetch codex in the background and add entity badges under each story.
  ensureCodexDataLoaded()
    .then(() => enhanceStoryEntityBadges())
    .catch(() => {/* non-fatal */});

  // Build genre filter buttons
  const genreBar = document.getElementById('genre-bar');
  genreBar.innerHTML = '';
  const allBtn = document.createElement('button');
  allBtn.className = 'btn genre-btn' + (activeGenre === 'all' ? ' active' : '');
  allBtn.dataset.genre = 'all';
  allBtn.textContent = 'All Tales';
  allBtn.addEventListener('click', () => applyGenreFilter('all'));
  genreBar.appendChild(allBtn);
  const seenGenres = new Set();
  data.stories.forEach(s => {
    const g = (s.subgenre || '').trim();
    if (g && !seenGenres.has(g.toLowerCase())) {
      seenGenres.add(g.toLowerCase());
      const btn = document.createElement('button');
      btn.className = 'btn genre-btn';
      btn.dataset.genre = g;
      btn.textContent = g;
      btn.addEventListener('click', () => applyGenreFilter(g));
      genreBar.appendChild(btn);
    }
  });

  applyGenreFilter(activeGenre);
  document.querySelectorAll('.archive-entry').forEach(el => {
    el.classList.toggle('active', el.dataset.date === data.date);
  });
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// â”€â”€ Story Modal (single-story preview) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function closeStoryModal() {
  document.getElementById('story-modal-overlay').classList.remove('open');
  document.getElementById('story-modal').classList.remove('open');
  document.getElementById('story-modal-title').textContent = 'â€”';
  document.getElementById('story-modal-sub').textContent = 'â€”';
  document.getElementById('story-modal-actions').innerHTML = '';
  const ents = document.getElementById('story-modal-entities');
  if (ents) {
    ents.innerHTML = '';
    ents.style.display = 'none';
    delete ents.dataset.enhanced;
  }
  const t = document.getElementById('story-modal-text');
  t.textContent = '';
  if (t && t.dataset) delete t.dataset.rawText;
}

function openStoryModalSkeleton() {
  document.getElementById('story-modal-overlay').classList.add('open');
  document.getElementById('story-modal').classList.add('open');
}

async function fetchDayStories(date) {
  const d = date || todayStr();
  if (STORY_DAY_CACHE.has(d)) return STORY_DAY_CACHE.get(d);

  const url = (d === todayStr()) ? (STORIES_URL + '?t=' + Date.now()) : (ARCHIVE_URL(d) + '?t=' + Date.now());
  const res = await fetch(url);
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json();
  if (!data || !Array.isArray(data.stories)) throw new Error('Invalid story payload.');
  STORY_DAY_CACHE.set(d, data);
  return data;
}

function findStoryInDay(dayData, title) {
  const want = String(title || '').trim().toLowerCase();
  if (!want || !dayData || !Array.isArray(dayData.stories)) return null;
  return dayData.stories.find(s => String(s && s.title ? s.title : '').trim().toLowerCase() === want) || null;
}

function normalizeAppearances(list) {
  if (!Array.isArray(list)) return [];
  const out = [];
  const seen = new Set();
  list.forEach(a => {
    if (!a) return;
    const d = String(a.date || '').trim();
    const t = String(a.title || '').trim();
    if (!d || !t) return;
    const key = `${d}::${t}`;
    if (seen.has(key)) return;
    seen.add(key);
    out.push({ date: d, title: t });
  });
  return out;
}

function storyModalIsOpen() {
  return document.getElementById('story-modal').classList.contains('open');
}

async function openStoryModalByAppearance(date, title, opts = {}) {
  const d = date || todayStr();
  const t = String(title || '').trim();
  if (!t) return;

  const appearances = normalizeAppearances(opts.appearances);
  const index = Number.isFinite(opts.index) ? opts.index : 0;
  STORY_MODAL_APPEARANCES = appearances;
  STORY_MODAL_INDEX = Math.max(0, Math.min(index, Math.max(0, appearances.length - 1)));

  openStoryModalSkeleton();
  document.getElementById('story-modal-title').textContent = 'Retrieving taleâ€¦';
  document.getElementById('story-modal-sub').textContent = d;

  try {
    const day = await fetchDayStories(d);
    const story = findStoryInDay(day, t);
    if (!story) throw new Error('Story not found in that issue.');

    document.getElementById('story-modal-title').textContent = story.title || 'Untitled';
    const sub = `${formatDate(day.date || d)} Â· ${(story.subgenre || 'Sword & Sorcery').toUpperCase()}`;
    document.getElementById('story-modal-sub').textContent = sub;

    const actions = document.getElementById('story-modal-actions');
    actions.innerHTML = '';
    const btnDay = document.createElement('button');
    btnDay.className = 'btn';
    btnDay.textContent = 'View Full Issue';
    btnDay.addEventListener('click', async () => {
      closeStoryModal();
      switchTab('tales');
      if (d === todayStr()) await loadTodayStories(); else await loadArchiveDate(d);
      // Best-effort scroll to the story within the day.
      const want = String(story.title || '').trim().toLowerCase();
      const match = Array.from(document.querySelectorAll('.story-card')).find(el => (el.dataset.title || '') === want);
      if (match) match.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });
    actions.appendChild(btnDay);

    if (appearances.length > 1) {
      const count = document.createElement('span');
      count.className = 'story-modal-count';
      count.textContent = `Appearance ${STORY_MODAL_INDEX + 1} / ${appearances.length}`;
      actions.appendChild(count);

      // Prev / Next navigation on the far right, after the count indicator.
      const prev = document.createElement('button');
      prev.className = 'btn btn-icon';
      prev.textContent = 'â€¹';
      prev.title = 'Previous appearance';
      prev.disabled = STORY_MODAL_INDEX <= 0;
      prev.addEventListener('click', () => {
        if (STORY_MODAL_INDEX <= 0) return;
        const nextIdx = STORY_MODAL_INDEX - 1;
        const app = appearances[nextIdx];
        openStoryModalByAppearance(app.date, app.title, { appearances, index: nextIdx });
      });
      actions.appendChild(prev);

      const next = document.createElement('button');
      next.className = 'btn btn-icon';
      next.textContent = 'â€º';
      next.title = 'Next appearance';
      next.disabled = STORY_MODAL_INDEX >= appearances.length - 1;
      next.addEventListener('click', () => {
        if (STORY_MODAL_INDEX >= appearances.length - 1) return;
        const nextIdx = STORY_MODAL_INDEX + 1;
        const app = appearances[nextIdx];
        openStoryModalByAppearance(app.date, app.title, { appearances, index: nextIdx });
      });
      actions.appendChild(next);
    }

    const rawText = fixMojibake(story.text || '');
    const textEl = document.getElementById('story-modal-text');
    textEl.dataset.rawText = rawText;
    textEl.textContent = rawText;

    // Show entity badges once codex data is ready.
    ensureCodexDataLoaded()
      .then(() => enhanceStoryEntityBadges())
      .catch(() => {/* non-fatal */});
  } catch (err) {
    console.error(err);
    document.getElementById('story-modal-title').textContent = 'âš  Could not open story';
    document.getElementById('story-modal-sub').textContent = `${d} Â· ${t}`;
    document.getElementById('story-modal-actions').innerHTML = '';
    document.getElementById('story-modal-text').textContent = (err && err.message) ? err.message : String(err);
  }
}

// â”€â”€ Fetch Today â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadTodayStories() {
  currentDate = null;
  setStatus('<span class="spinner"></span><em>Summoning the storiesâ€¦</em>');
  try {
    const res = await fetch(STORIES_URL + '?t=' + Date.now());
    if (!res.ok) {
      if (res.status === 404) {
        setStatus(`<div class="error-box"><strong>âš” No Tales Yet</strong> The scribes haven't conjured today's stories yet. Check back after 6 AM UTC.</div>`);
      } else { throw new Error(`HTTP ${res.status}`); }
      return;
    }
    const data = await res.json();
    if (!data.stories || data.stories.length === 0) throw new Error('stories.json has no stories.');
    renderStories(data);
  } catch (err) {
    console.error(err);
    setStatus(errorBoxHtml('âš  The Ritual Failed', `Could not load stories: ${err && err.message ? err.message : String(err)}`));
  }
}

// â”€â”€ Fetch Archive Entry â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadArchiveDate(date) {
  currentDate = date;
  closeArchive();
  setStatus('<span class="spinner"></span><em>Retrieving tales from the vaultâ€¦</em>');
  try {
    const res = await fetch(ARCHIVE_URL(date) + '?t=' + Date.now());
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const data = await res.json();
    if (!data.stories || data.stories.length === 0) throw new Error('No stories in archive entry.');
    renderStories(data);
  } catch (err) {
    console.error(err);
    setStatus(errorBoxHtml('âš  The Vault is Sealed', `Could not retrieve tales from ${date}: ${err && err.message ? err.message : String(err)}`));
  }
}

// â”€â”€ Status badge helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function statusBadgeClass(status) {
  if (!status) return 'badge-status-default';
  const s = status.toLowerCase();
  if (s.includes('active')) return 'badge-status-active';
  if (s.includes('dead') || s.includes('deceased')) return 'badge-status-dead';
  if (s.includes('undead') || s.includes('zombie') || s.includes('wight') || s.includes('ghoul')) return 'badge-status-dead';
  if (s.includes('reanim') || s.includes('reviv') || s.includes('resurrect')) return 'badge-status-changed';
  if (s.includes('curs')) return 'badge-status-cursed';
  if (s.includes('chang')) return 'badge-status-changed';
  if (s.includes('unknown')) return 'badge-status-unknown';
  return 'badge-status-default';
}

function travelBadge(scope) {
  const s = String(scope || '').trim().toLowerCase();
  if (!s) return '';
  const map = {
    local: { cls: 'badge-travel-local', label: 'Local' },
    regional: { cls: 'badge-travel-regional', label: 'Regional' },
    realmwide: { cls: 'badge-travel-realmwide', label: 'Realmwide' },
    interrealm: { cls: 'badge-travel-interrealm', label: 'Interrealm' },
    unknown: { cls: 'badge-travel-unknown', label: 'Range Unknown' },
  };
  const item = map[s];
  if (!item) return '';
  return `<span class="badge ${item.cls}" title="Travel scope">${escHtml(item.label)}</span>`;
}

// â”€â”€ Story link builder â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildStoryLinks(appearances, firstStory, firstDate) {
  let list = Array.isArray(appearances) ? appearances.filter(s => s && s.title) : [];

  // Defensive fallback: some entries have first_story/first_date but missing story_appearances.
  if (list.length === 0 && firstStory) {
    list = [{ date: firstDate || todayStr(), title: firstStory }];
  }

  // De-dupe by date+title (keeps stable ordering).
  const seen = new Set();
  list = list.filter(s => {
    const key = `${s.date || ''}::${s.title || ''}`;
    if (seen.has(key)) return false;
    seen.add(key);
    return true;
  });

  if (list.length === 0) return '';

  // Embed the full appearance list so the modal can navigate prev/next.
  const payload = escHtml(encodeURIComponent(JSON.stringify(list.map(s => ({
    date: s.date || todayStr(),
    title: s.title || ''
  })) )));

  const links = list.map(s =>
    `<button class="codex-story-link" data-date="${escHtml(s.date || todayStr())}" data-title="${escHtml(s.title)}">${escHtml(s.title)}</button>`
  ).join('');
  return `<div class="codex-story-links" data-appearances="${payload}"><span class="codex-story-links-label">Appears in</span>${links}</div>`;
}

function attachStoryLinkListeners(card) {
  card.querySelectorAll('.codex-story-link').forEach(btn => {
    btn.addEventListener('click', () => {
      const d = btn.dataset.date;
      const t = btn.dataset.title || btn.textContent || '';

      let appearances = [];
      try {
        const wrap = btn.closest('.codex-story-links');
        const raw = wrap && wrap.dataset && wrap.dataset.appearances ? wrap.dataset.appearances : '';
        if (raw) appearances = JSON.parse(decodeURIComponent(raw));
      } catch (e) { appearances = []; }
      appearances = normalizeAppearances(appearances);
      const idx = appearances.findIndex(a => (a.date || '') === (d || '') && String(a.title || '').trim() === String(t || '').trim());

      openStoryModalByAppearance(d, t, { appearances, index: idx >= 0 ? idx : 0 });
    });
  });
}

// â”€â”€ Geography helpers (place hierarchy) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function truthyNonUnknown(val) {
  const v = String(val || '').trim();
  if (!v) return false;
  return !['unknown', 'n/a', 'na', 'none'].includes(v.toLowerCase());
}

// Filled during renderCodex so helpers can label parent places (e.g., City).
let PLACE_TYPE_BY_NAME = new Map();

function buildPlaceGeoMeta(p) {
  const region = truthyNonUnknown(p.region) ? p.region : '';
  const realm = truthyNonUnknown(p.realm) ? p.realm : '';
  if (!region && !realm) return '';

  const parts = [];
  if (region) parts.push(`<span><strong>Region:</strong> ${escHtml(region)}</span>`);
  if (realm) parts.push(`<span><strong>Realm:</strong> ${escHtml(realm)}</span>`);
  return `<div class="codex-meta">${parts.join('')}</div>`;
}

function buildEntityGeoMeta(e, opts = {}) {
  const includePlace = opts.includePlace !== false;
  const place = includePlace && truthyNonUnknown(e.place) ? e.place : '';
  const region = truthyNonUnknown(e.region) ? e.region : '';
  const realm = truthyNonUnknown(e.realm) ? e.realm : '';
  if (!place && !region && !realm) return '';

  const parts = [];
  if (place) parts.push(`<span><strong>Place:</strong> ${escHtml(place)}</span>`);
  if (region) parts.push(`<span><strong>Region:</strong> ${escHtml(region)}</span>`);
  if (realm) parts.push(`<span><strong>Realm:</strong> ${escHtml(realm)}</span>`);
  return `<div class="codex-meta">${parts.join('')}</div>`;
}

function buildMostSpecificLocationLine(e, opts = {}) {
  const includePlace = opts.includePlace !== false;
  const defaultWorld = 'The Known World';
  const showWorldFallback = opts.showWorldFallback === true;
  const nameLower = String(e && e.name ? e.name : '').trim().toLowerCase();
  const parentPlace = truthyNonUnknown(e && e.parent_place) ? String(e.parent_place).trim() : '';
  const parentType = parentPlace ? (PLACE_TYPE_BY_NAME.get(parentPlace.toLowerCase()) || '') : '';
  const parentLabel = parentType && parentType.toLowerCase() === 'city' ? 'City' : 'In Place';

  const candidates = [
    { label: 'Place', value: includePlace ? e.place : '', skipIfSameName: true },
    { label: parentLabel, value: (!includePlace && parentPlace) ? parentPlace : '' },
    { label: 'District', value: e.district },
    { label: 'Region', value: e.region },
    { label: 'Province', value: e.province },
    { label: 'Realm', value: e.realm },
    { label: 'Subcontinent', value: e.subcontinent },
    { label: 'Continent', value: e.continent },
    { label: 'Hemisphere', value: e.hemisphere },
  ];

  for (const c of candidates) {
    const v = truthyNonUnknown(c.value) ? String(c.value).trim() : '';
    if (!v) continue;
    if (c.skipIfSameName && nameLower && v.toLowerCase() === nameLower) continue;
    return `<div class="codex-meta"><span><strong>Where:</strong> ${escHtml(c.label)} â€” ${escHtml(v)}</span></div>`;
  }

  const w = truthyNonUnknown(e.world) ? String(e.world).trim() : defaultWorld;
  // If the only known location is the default world, hide this line to reduce noise.
  if (!showWorldFallback && (!w || w === defaultWorld)) return '';
  return `<div class="codex-meta"><span><strong>Where:</strong> World â€” ${escHtml(w || defaultWorld)}</span></div>`;
}

function buildPlaceParentChain(p) {
  const world = truthyNonUnknown(p.world) ? p.world : '';
  const hemisphere = truthyNonUnknown(p.hemisphere) ? p.hemisphere : '';
  const continent = truthyNonUnknown(p.continent) ? p.continent : '';
  const subcontinent = truthyNonUnknown(p.subcontinent) ? p.subcontinent : '';
  const realm = truthyNonUnknown(p.realm) ? p.realm : '';
  const province = truthyNonUnknown(p.province) ? p.province : '';
  const region = truthyNonUnknown(p.region) ? p.region : '';
  const district = truthyNonUnknown(p.district) ? p.district : '';
  const parentPlace = truthyNonUnknown(p.parent_place) ? p.parent_place : '';
  const parentType = parentPlace ? (PLACE_TYPE_BY_NAME.get(String(parentPlace).toLowerCase()) || '') : '';
  const parentRowLabel = parentType && String(parentType).toLowerCase() === 'city' ? 'City' : 'Within';

  const hasOther = hemisphere || continent || subcontinent || realm || province || region || district || parentPlace;
  const worldVal = world || 'The Known World';

  const rows = [];
  rows.push(`<div class="geo-row"><strong>World</strong><span>${escHtml(worldVal)}</span></div>`);
  if (hemisphere) rows.push(`<div class="geo-row"><strong>Hemisphere</strong><span>${escHtml(hemisphere)}</span></div>`);
  if (continent) rows.push(`<div class="geo-row"><strong>Continent</strong><span>${escHtml(continent)}</span></div>`);
  if (subcontinent) rows.push(`<div class="geo-row"><strong>Subcontinent</strong><span>${escHtml(subcontinent)}</span></div>`);
  if (realm) rows.push(`<div class="geo-row"><strong>Realm</strong><span>${escHtml(realm)}</span></div>`);
  if (province) rows.push(`<div class="geo-row"><strong>Province</strong><span>${escHtml(province)}</span></div>`);
  if (region) rows.push(`<div class="geo-row"><strong>Region</strong><span>${escHtml(region)}</span></div>`);
  if (district) rows.push(`<div class="geo-row"><strong>District</strong><span>${escHtml(district)}</span></div>`);
  if (parentPlace && (!p.name || parentPlace.toLowerCase() !== String(p.name).toLowerCase())) rows.push(`<div class="geo-row"><strong>${escHtml(parentRowLabel)}</strong><span>${escHtml(parentPlace)}</span></div>`);
  if (!hasOther) rows.push(`<div class="geo-row"><strong>Hierarchy</strong><span>Unknown</span></div>`);

  return `
    <details class="codex-geo-details">
      <summary>Where in the world?</summary>
      <div class="codex-geo-chain">${rows.join('')}</div>
    </details>
  `;
}

function buildEntityParentChain(e, opts = {}) {
  const hidePlaceRow = !!opts.hidePlaceRow;
  const world = truthyNonUnknown(e.world) ? e.world : '';
  const hemisphere = truthyNonUnknown(e.hemisphere) ? e.hemisphere : '';
  const continent = truthyNonUnknown(e.continent) ? e.continent : '';
  const subcontinent = truthyNonUnknown(e.subcontinent) ? e.subcontinent : '';
  const realm = truthyNonUnknown(e.realm) ? e.realm : '';
  const province = truthyNonUnknown(e.province) ? e.province : '';
  const region = truthyNonUnknown(e.region) ? e.region : '';
  const district = truthyNonUnknown(e.district) ? e.district : '';
  const parentPlace = truthyNonUnknown(e.parent_place) ? e.parent_place : '';
  const parentType = parentPlace ? (PLACE_TYPE_BY_NAME.get(String(parentPlace).toLowerCase()) || '') : '';
  const parentRowLabel = parentType && String(parentType).toLowerCase() === 'city' ? 'City' : 'Within';
  const place = !hidePlaceRow && truthyNonUnknown(e.place) ? e.place : '';

  const hasOther = hemisphere || continent || subcontinent || realm || province || region || district || parentPlace || place;
  const worldVal = world || 'The Known World';

  const rows = [];
  rows.push(`<div class="geo-row"><strong>World</strong><span>${escHtml(worldVal)}</span></div>`);
  if (hemisphere) rows.push(`<div class="geo-row"><strong>Hemisphere</strong><span>${escHtml(hemisphere)}</span></div>`);
  if (continent) rows.push(`<div class="geo-row"><strong>Continent</strong><span>${escHtml(continent)}</span></div>`);
  if (subcontinent) rows.push(`<div class="geo-row"><strong>Subcontinent</strong><span>${escHtml(subcontinent)}</span></div>`);
  if (realm) rows.push(`<div class="geo-row"><strong>Realm</strong><span>${escHtml(realm)}</span></div>`);
  if (province) rows.push(`<div class="geo-row"><strong>Province</strong><span>${escHtml(province)}</span></div>`);
  if (region) rows.push(`<div class="geo-row"><strong>Region</strong><span>${escHtml(region)}</span></div>`);
  if (district) rows.push(`<div class="geo-row"><strong>District</strong><span>${escHtml(district)}</span></div>`);
  if (parentPlace && (!e.name || parentPlace.toLowerCase() !== String(e.name).toLowerCase())) rows.push(`<div class="geo-row"><strong>${escHtml(parentRowLabel)}</strong><span>${escHtml(parentPlace)}</span></div>`);
  if (place && (!e.name || place.toLowerCase() !== String(e.name).toLowerCase())) rows.push(`<div class="geo-row"><strong>Place</strong><span>${escHtml(place)}</span></div>`);
  if (!hasOther) rows.push(`<div class="geo-row"><strong>Hierarchy</strong><span>Unknown</span></div>`);

  return `
    <details class="codex-geo-details">
      <summary>Where in the world?</summary>
      <div class="codex-geo-chain">${rows.join('')}</div>
    </details>
  `;
}

// â”€â”€ Render Codex â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderCodex(data) {
  const statusEl = document.getElementById('char-status-msg');
  const grid     = document.getElementById('char-grid');
  statusEl.style.display = 'none';
  grid.innerHTML = '';
  grid.style.display = '';

  const byName = (a, b) => {
    const an = String((a && a.name) ? a.name : '').toLowerCase();
    const bn = String((b && b.name) ? b.name : '').toLowerCase();
    return an.localeCompare(bn);
  };

  // Default Codex ordering: alphabetical within each category.
  const characters = [...(data.characters || [])].sort(byName);
  const places     = [...(data.places     || [])].sort(byName);
  // Build place-type lookup for labeling parent places.
  PLACE_TYPE_BY_NAME = new Map();
  places.forEach(p => {
    const nm = String(p && p.name ? p.name : '').trim();
    if (!nm) return;
    const pt = String(p && p.place_type ? p.place_type : '').trim().toLowerCase();
    if (pt) PLACE_TYPE_BY_NAME.set(nm.toLowerCase(), pt);
  });

  const hemispheres = [...(data.hemispheres || [])].sort(byName);
  const continents  = [...(data.continents  || [])].sort(byName);
  const subcontinents = [...(data.subcontinents || [])].sort(byName);
  const realms      = [...(data.realms      || [])].sort(byName);
  const provinces   = [...(data.provinces   || [])].sort(byName);
  const districts   = [...(data.districts   || [])].sort(byName);
  const events      = [...(data.events      || [])].sort(byName);
  const weapons     = [...(data.weapons     || [])].sort(byName);
  const artifacts   = [...(data.artifacts   || [])].sort(byName);
  const factions    = [...(data.factions    || [])].sort(byName);
  const lore        = [...(data.lore        || [])].sort(byName);
  const flora_fauna = [...(data.flora_fauna || [])].sort(byName);
  const magic       = [...(data.magic       || [])].sort(byName);
  const relics      = [...(data.relics      || [])].sort(byName);
  const regions     = [...(data.regions     || [])].sort(byName);
  const substances  = [...(data.substances  || [])].sort(byName);

  const total = characters.length + places.length + hemispheres.length + continents.length + subcontinents.length + realms.length + provinces.length + districts.length + events.length + weapons.length + artifacts.length + factions.length + lore.length + flora_fauna.length + magic.length + relics.length + regions.length + substances.length;

  if (total === 0) {
    statusEl.innerHTML = '<em>The codex is empty. Return after the backfill workflow completes.</em>';
    statusEl.style.display = '';
    return;
  }

  // â”€â”€ Characters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  characters.forEach(c => {
    const card = document.createElement('div');
    card.className = 'codex-card char-card';
    stampCodexCardMeta(card, 'characters', c.name, _primaryLabelTokensForEntity('characters', c));
    const statusClass = statusBadgeClass(c.status);
    const statusHist = Array.isArray(c.status_history) ? c.status_history : [];
    const lastStatusEvent = statusHist.length ? statusHist[statusHist.length - 1] : null;
    const statusEventLine = (() => {
      if (!lastStatusEvent) return '';
      const d = lastStatusEvent.date ? ` (${lastStatusEvent.date})` : '';
      const fromS = (lastStatusEvent.from_status || '').trim();
      const toS = (lastStatusEvent.to_status || '').trim();
      if (fromS && toS && fromS.toLowerCase() !== toS.toLowerCase()) {
        return `Once ${fromS} â†’ now ${toS}${d}`;
      }
      if (lastStatusEvent.note) return `${lastStatusEvent.note}${d}`;
      if (lastStatusEvent.type && lastStatusEvent.story_title) return `${lastStatusEvent.type}: ${lastStatusEvent.story_title}${d}`;
      return d ? d.trim() : '';
    })();
    const traits = (c.traits || []).map(t =>
      `<span class="char-trait">${escHtml(t)}</span>`
    ).join('');
    const appearances = c.appearances > 1 ? `${c.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Character</span>
      <div class="codex-card-name">${escHtml(c.name)}</div>
      ${c.tagline ? `<div class="codex-card-tagline">${escHtml(c.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-role">${escHtml(c.role || 'Unknown')}</span>
        <span class="badge ${statusClass}">${escHtml(c.status && c.status.toLowerCase() === 'deceased' ? 'Dead' : (c.status || 'Unknown'))}</span>
        ${travelBadge(c.travel_scope)}
      </div>
      ${statusEventLine ? `<div class="codex-meta"><span>${escHtml(statusEventLine)}</span></div>` : ''}
      ${buildMostSpecificLocationLine(c, { includePlace: true })}
      ${buildEntityParentChain(c)}
      <hr class="codex-divider" />
      <div class="codex-body">${escHtml(c.bio || '')}</div>
      ${traits ? `<div class="char-traits">${traits}</div>` : ''}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${c.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(c.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(c.story_appearances, c.first_story, c.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Places â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  places.forEach(p => {
    const card = document.createElement('div');
    card.className = 'codex-card place-card';
    stampCodexCardMeta(card, 'places', p.name, _primaryLabelTokensForEntity('places', p));
    const appearances = p.appearances > 1 ? `${p.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Place</span>
      <div class="codex-card-name">${escHtml(p.name)}</div>
      ${p.tagline ? `<div class="codex-card-tagline">${escHtml(p.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-place">${escHtml(p.place_type || 'Location')}</span>
        ${p.status ? `<span class="badge badge-status-default">${escHtml(p.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${p.atmosphere ? `<div class="place-atmosphere">${escHtml(p.atmosphere)}</div>` : ''}
      ${buildMostSpecificLocationLine(p, { includePlace: false })}
      <div class="codex-body">${escHtml(p.description || '')}</div>
      ${buildEntityParentChain(p, { hidePlaceRow: true })}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${p.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(p.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(p.story_appearances, p.first_story, p.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Hemispheres â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  hemispheres.forEach(h => {
    const card = document.createElement('div');
    card.className = 'codex-card geo-card';
    stampCodexCardMeta(card, 'hemispheres', h.name, _primaryLabelTokensForEntity('hemispheres', h));
    const appearances = h.appearances > 1 ? `${h.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Hemisphere</span>
      <div class="codex-card-name">${escHtml(h.name)}</div>
      ${h.tagline ? `<div class="codex-card-tagline">${escHtml(h.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-region">${escHtml(h.climate || 'Hemisphere')}</span>
        ${h.status ? `<span class="badge badge-status-default">${escHtml(h.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${buildMostSpecificLocationLine(h)}
      <div class="codex-body">${escHtml(h.description || '')}</div>
      ${buildEntityParentChain(h)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${h.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(h.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(h.story_appearances, h.first_story, h.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Continents â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  continents.forEach(cn => {
    const card = document.createElement('div');
    card.className = 'codex-card geo-card';
    stampCodexCardMeta(card, 'continents', cn.name, _primaryLabelTokensForEntity('continents', cn));
    const appearances = cn.appearances > 1 ? `${cn.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Continent</span>
      <div class="codex-card-name">${escHtml(cn.name)}</div>
      ${cn.tagline ? `<div class="codex-card-tagline">${escHtml(cn.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-region">${escHtml(cn.climate || 'Continent')}</span>
        ${cn.status ? `<span class="badge badge-status-default">${escHtml(cn.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${buildMostSpecificLocationLine(cn)}
      <div class="codex-body">${escHtml(cn.description || '')}</div>
      ${buildEntityParentChain(cn)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${cn.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(cn.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(cn.story_appearances, cn.first_story, cn.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Subcontinents â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  subcontinents.forEach(sc => {
    const card = document.createElement('div');
    card.className = 'codex-card geo-card';
    stampCodexCardMeta(card, 'subcontinents', sc.name, _primaryLabelTokensForEntity('subcontinents', sc));
    const appearances = sc.appearances > 1 ? `${sc.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Subcontinent</span>
      <div class="codex-card-name">${escHtml(sc.name)}</div>
      ${sc.tagline ? `<div class="codex-card-tagline">${escHtml(sc.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-region">${escHtml(sc.climate || 'Subcontinent')}</span>
        ${sc.status ? `<span class="badge badge-status-default">${escHtml(sc.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${buildMostSpecificLocationLine(sc)}
      <div class="codex-body">${escHtml(sc.description || '')}</div>
      ${buildEntityParentChain(sc)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${sc.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(sc.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(sc.story_appearances, sc.first_story, sc.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Realms â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  realms.forEach(rm => {
    const card = document.createElement('div');
    card.className = 'codex-card geo-card';
    stampCodexCardMeta(card, 'realms', rm.name, _primaryLabelTokensForEntity('realms', rm));
    const appearances = rm.appearances > 1 ? `${rm.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Realm</span>
      <div class="codex-card-name">${escHtml(rm.name)}</div>
      ${rm.tagline ? `<div class="codex-card-tagline">${escHtml(rm.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-region">${escHtml(rm.climate || 'Realm')}</span>
        ${rm.status ? `<span class="badge badge-status-default">${escHtml(rm.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${buildMostSpecificLocationLine(rm)}
      <div class="codex-body">${escHtml(rm.description || '')}</div>
      ${buildEntityParentChain(rm)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${rm.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(rm.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(rm.story_appearances, rm.first_story, rm.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Provinces â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  provinces.forEach(pv => {
    const card = document.createElement('div');
    card.className = 'codex-card geo-card';
    stampCodexCardMeta(card, 'provinces', pv.name, _primaryLabelTokensForEntity('provinces', pv));
    const appearances = pv.appearances > 1 ? `${pv.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Province</span>
      <div class="codex-card-name">${escHtml(pv.name)}</div>
      ${pv.tagline ? `<div class="codex-card-tagline">${escHtml(pv.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-region">${escHtml(pv.climate || 'Province')}</span>
        ${pv.status ? `<span class="badge badge-status-default">${escHtml(pv.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${buildMostSpecificLocationLine(pv)}
      <div class="codex-body">${escHtml(pv.description || '')}</div>
      ${buildEntityParentChain(pv)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${pv.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(pv.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(pv.story_appearances, pv.first_story, pv.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Districts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  districts.forEach(dt => {
    const card = document.createElement('div');
    card.className = 'codex-card geo-card';
    stampCodexCardMeta(card, 'districts', dt.name, _primaryLabelTokensForEntity('districts', dt));
    const appearances = dt.appearances > 1 ? `${dt.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">District</span>
      <div class="codex-card-name">${escHtml(dt.name)}</div>
      ${dt.tagline ? `<div class="codex-card-tagline">${escHtml(dt.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-region">${escHtml(dt.climate || 'District')}</span>
        ${dt.status ? `<span class="badge badge-status-default">${escHtml(dt.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${buildMostSpecificLocationLine(dt)}
      <div class="codex-body">${escHtml(dt.description || '')}</div>
      ${buildEntityParentChain(dt)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${dt.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(dt.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(dt.story_appearances, dt.first_story, dt.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  events.forEach(e => {
    const card = document.createElement('div');
    card.className = 'codex-card event-card';
    stampCodexCardMeta(card, 'events', e.name, _primaryLabelTokensForEntity('events', e));
    const participants = (e.participants || []).map(p => escHtml(p)).join(', ');
    const appearances = e.appearances > 1 ? `${e.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Event</span>
      <div class="codex-card-name">${escHtml(e.name)}</div>
      ${e.tagline ? `<div class="codex-card-tagline">${escHtml(e.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-event">${escHtml(e.event_type || 'Event')}</span>
      </div>
      <hr class="codex-divider" />
      ${participants ? `<div class="event-participants"><strong>Participants:</strong>${participants}</div>` : ''}
      <div class="codex-body">${escHtml(e.outcome || '')}</div>
      ${e.significance ? `<div class="event-significance">${escHtml(e.significance)}</div>` : ''}
      ${buildMostSpecificLocationLine(e)}
      ${buildEntityParentChain(e)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${e.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(e.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(e.story_appearances, e.first_story, e.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Weapons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  weapons.forEach(w => {
    const card = document.createElement('div');
    card.className = 'codex-card weapon-card';
    stampCodexCardMeta(card, 'weapons', w.name, _primaryLabelTokensForEntity('weapons', w));
    const appearances = w.appearances > 1 ? `${w.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Weapon</span>
      <div class="codex-card-name">${escHtml(w.name)}</div>
      ${w.tagline ? `<div class="codex-card-tagline">${escHtml(w.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-weapon">${escHtml(w.weapon_type || 'Weapon')}</span>
        ${w.status ? `<span class="badge badge-status-default">${escHtml(w.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${w.origin ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Origin:</em> ${escHtml(w.origin)}</div>` : ''}
      <div class="codex-body">${escHtml(w.powers || '')}</div>
      ${w.last_known_holder ? `<div class="weapon-holder">Last held by: ${escHtml(w.last_known_holder)}</div>` : ''}
      ${buildMostSpecificLocationLine(w)}
      ${buildEntityParentChain(w)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${w.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(w.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(w.story_appearances, w.first_story, w.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€ Artifacts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  artifacts.forEach(a => {
    const card = document.createElement('div');
    card.className = 'codex-card artifact-card';
    stampCodexCardMeta(card, 'artifacts', a.name, _primaryLabelTokensForEntity('artifacts', a));
    const appearances = a.appearances > 1 ? `${a.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <span class="codex-type-label">Artifact</span>
      <div class="codex-card-name">${escHtml(a.name)}</div>
      ${a.tagline ? `<div class="codex-card-tagline">${escHtml(a.tagline)}</div>` : ''}
      <div class="codex-card-badges">
        <span class="badge badge-artifact">${escHtml(a.artifact_type || 'Artifact')}</span>
        ${a.status ? `<span class="badge badge-status-default">${escHtml(a.status)}</span>` : ''}
      </div>
      <hr class="codex-divider" />
      ${a.origin ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Origin:</em> ${escHtml(a.origin)}</div>` : ''}
      <div class="codex-body">${escHtml(a.powers || '')}</div>
      ${a.last_known_holder ? `<div class="artifact-holder">Last held by: ${escHtml(a.last_known_holder)}</div>` : ''}
      ${buildMostSpecificLocationLine(a)}
      ${buildEntityParentChain(a)}
      <div class="codex-card-footer">
        <span class="codex-appearances">${appearances}</span>
        ${a.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(a.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(a.story_appearances, a.first_story, a.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€â”€ Factions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  factions.forEach(f => {
    const card = document.createElement('div');
    card.className = 'codex-card faction-card';
    stampCodexCardMeta(card, 'factions', f.name, _primaryLabelTokensForEntity('factions', f));
    const appearances = f.appearances > 1 ? `${f.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <div class="codex-card-header">
        <div class="codex-card-name">${escHtml(f.name)}</div>
        ${f.tagline ? `<div class="codex-card-tagline">${escHtml(f.tagline)}</div>` : ''}
        <div class="codex-card-badges">
          <span class="badge badge-faction">${escHtml(f.alignment || 'Faction')}</span>
          ${f.status ? `<span class="badge badge-status-default">${escHtml(f.status)}</span>` : ''}
        </div>
      </div>
      <hr class="codex-divider" />
      ${f.leader ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Leader:</em> ${escHtml(f.leader)}</div>` : ''}
      <div class="codex-body">${escHtml(f.description || '')}</div>
      ${f.goals ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Goals:</em> ${escHtml(f.goals)}</div>` : ''}
      ${buildMostSpecificLocationLine(f)}
      ${buildEntityParentChain(f)}
      <div class="codex-meta">
        <span>${appearances}</span>
        ${f.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(f.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(f.story_appearances, f.first_story, f.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€â”€ Lore â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  lore.forEach(l => {
    const card = document.createElement('div');
    card.className = 'codex-card lore-card';
    stampCodexCardMeta(card, 'lore', l.name, _primaryLabelTokensForEntity('lore', l));
    const appearances = l.appearances > 1 ? `${l.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <div class="codex-card-header">
        <div class="codex-card-name">${escHtml(l.name)}</div>
        ${l.tagline ? `<div class="codex-card-tagline">${escHtml(l.tagline)}</div>` : ''}
        <div class="codex-card-badges">
          <span class="badge badge-lore">${escHtml(l.category || 'Lore')}</span>
          ${l.status ? `<span class="badge badge-status-default">${escHtml(l.status)}</span>` : ''}
        </div>
      </div>
      <hr class="codex-divider" />
      ${l.source ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Source:</em> ${escHtml(l.source)}</div>` : ''}
      <div class="codex-body">${escHtml(l.description || '')}</div>
      ${buildMostSpecificLocationLine(l)}
      ${buildEntityParentChain(l)}
      <div class="codex-meta">
        <span>${appearances}</span>
        ${l.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(l.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(l.story_appearances, l.first_story, l.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€â”€ Flora_fauna â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  flora_fauna.forEach(ff => {
    const card = document.createElement('div');
    card.className = 'codex-card flora-card';
    stampCodexCardMeta(card, 'flora_fauna', ff.name, _primaryLabelTokensForEntity('flora_fauna', ff));
    const appearances = ff.appearances > 1 ? `${ff.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <div class="codex-card-header">
        <div class="codex-card-name">${escHtml(ff.name)}</div>
        ${ff.tagline ? `<div class="codex-card-tagline">${escHtml(ff.tagline)}</div>` : ''}
        <div class="codex-card-badges">
          <span class="badge badge-flora">${escHtml(ff.type || 'Flora')}</span>
          ${ff.status ? `<span class="badge badge-status-default">${escHtml(ff.status)}</span>` : ''}
        </div>
      </div>
      <hr class="codex-divider" />
      ${ff.habitat ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Habitat:</em> ${escHtml(ff.habitat)}</div>` : ''}
      <div class="codex-body">${escHtml(ff.description || '')}</div>
      ${buildMostSpecificLocationLine(ff)}
      ${buildEntityParentChain(ff)}
      ${ff.rarity ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Rarity:</em> ${escHtml(ff.rarity)}</div>` : ''}
      <div class="codex-meta">
        <span>${appearances}</span>
        ${ff.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(ff.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(ff.story_appearances, ff.first_story, ff.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€â”€ Magic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  magic.forEach(m => {
    const card = document.createElement('div');
    card.className = 'codex-card magic-card';
    stampCodexCardMeta(card, 'magic', m.name, _primaryLabelTokensForEntity('magic', m));
    const appearances = m.appearances > 1 ? `${m.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <div class="codex-card-header">
        <div class="codex-card-name">${escHtml(m.name)}</div>
        ${m.tagline ? `<div class="codex-card-tagline">${escHtml(m.tagline)}</div>` : ''}
        <div class="codex-card-badges">
          <span class="badge badge-magic">${escHtml(m.type || 'Magic')}</span>
          ${m.status ? `<span class="badge badge-status-default">${escHtml(m.status)}</span>` : ''}
        </div>
      </div>
      <hr class="codex-divider" />
      ${m.element ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Element:</em> ${escHtml(m.element)}</div>` : ''}
      <div class="codex-body">${escHtml(m.description || '')}</div>
      ${buildMostSpecificLocationLine(m)}
      ${buildEntityParentChain(m)}
      ${m.difficulty ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Difficulty:</em> ${escHtml(m.difficulty)}</div>` : ''}
      <div class="codex-meta">
        <span>${appearances}</span>
        ${m.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(m.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(m.story_appearances, m.first_story, m.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€â”€ Relics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  relics.forEach(r => {
    const card = document.createElement('div');
    card.className = 'codex-card relic-card';
    stampCodexCardMeta(card, 'relics', r.name, _primaryLabelTokensForEntity('relics', r));
    const appearances = r.appearances > 1 ? `${r.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <div class="codex-card-header">
        <div class="codex-card-name">${escHtml(r.name)}</div>
        ${r.tagline ? `<div class="codex-card-tagline">${escHtml(r.tagline)}</div>` : ''}
        <div class="codex-card-badges">
          <span class="badge badge-relic">${escHtml(r.origin || 'Relic')}</span>
          ${r.status ? `<span class="badge badge-status-default">${escHtml(r.status)}</span>` : ''}
        </div>
      </div>
      <hr class="codex-divider" />
      ${r.curse ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Curse:</em> ${escHtml(r.curse)}</div>` : ''}
      <div class="codex-body">${escHtml(r.description || '')}</div>
      ${buildMostSpecificLocationLine(r)}
      ${buildEntityParentChain(r)}
      ${r.power ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Power:</em> ${escHtml(r.power)}</div>` : ''}
      <div class="codex-meta">
        <span>${appearances}</span>
        ${r.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(r.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(r.story_appearances, r.first_story, r.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€â”€ Regions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  regions.forEach(reg => {
    const card = document.createElement('div');
    card.className = 'codex-card region-card';
    stampCodexCardMeta(card, 'regions', reg.name, _primaryLabelTokensForEntity('regions', reg));
    const appearances = reg.appearances > 1 ? `${reg.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <div class="codex-card-header">
        <div class="codex-card-name">${escHtml(reg.name)}</div>
        ${reg.tagline ? `<div class="codex-card-tagline">${escHtml(reg.tagline)}</div>` : ''}
        <div class="codex-card-badges">
          <span class="badge badge-region">${escHtml(reg.climate || 'Region')}</span>
          ${reg.status ? `<span class="badge badge-status-default">${escHtml(reg.status)}</span>` : ''}
        </div>
      </div>
      <hr class="codex-divider" />
      ${reg.ruler ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Ruler:</em> ${escHtml(reg.ruler)}</div>` : ''}
      <div class="codex-body">${escHtml(reg.description || '')}</div>
      ${buildMostSpecificLocationLine(reg)}
      ${buildEntityParentChain(reg)}
      ${reg.terrain ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Terrain:</em> ${escHtml(reg.terrain)}</div>` : ''}
      <div class="codex-meta">
        <span>${appearances}</span>
        ${reg.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(reg.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(reg.story_appearances, reg.first_story, reg.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  // â”€â”€â”€ Substances â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  substances.forEach(sub => {
    const card = document.createElement('div');
    card.className = 'codex-card substance-card';
    stampCodexCardMeta(card, 'substances', sub.name, _primaryLabelTokensForEntity('substances', sub));
    const appearances = sub.appearances > 1 ? `${sub.appearances} appearances` : 'First appearance';
    card.innerHTML = `
      <div class="codex-card-header">
        <div class="codex-card-name">${escHtml(sub.name)}</div>
        ${sub.tagline ? `<div class="codex-card-tagline">${escHtml(sub.tagline)}</div>` : ''}
        <div class="codex-card-badges">
          <span class="badge badge-substance">${escHtml(sub.rarity || 'Substance')}</span>
          ${sub.status ? `<span class="badge badge-status-default">${escHtml(sub.status)}</span>` : ''}
        </div>
      </div>
      <hr class="codex-divider" />
      ${sub.properties ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Properties:</em> ${escHtml(sub.properties)}</div>` : ''}
      <div class="codex-body">${escHtml(sub.description || '')}</div>
      ${buildMostSpecificLocationLine(sub)}
      ${buildEntityParentChain(sub)}
      ${sub.use ? `<div class="codex-body" style="margin-bottom:.3rem"><em style="color:var(--muted);font-size:.78rem">Use:</em> ${escHtml(sub.use)}</div>` : ''}
      <div class="codex-meta">
        <span>${appearances}</span>
        ${sub.first_story ? `<span style="font-size:.72rem;color:var(--muted)">First: ${escHtml(sub.first_story)}</span>` : ''}
      </div>
      ${buildStoryLinks(sub.story_appearances, sub.first_story, sub.first_date)}
    `;
    attachStoryLinkListeners(card);
    grid.appendChild(card);
  });

  refreshCodexLabelOptions();
  applyCodexFilter(activeCodexType);
}

// â”€â”€ Fetch Codex â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadCodex(force = false) {
  if (codexLoaded && !force) return;
  const statusEl = document.getElementById('char-status-msg');
  const grid     = document.getElementById('char-grid');
  statusEl.innerHTML = '<span class="spinner"></span><em>Consulting the lore scrollsâ€¦</em>';
  statusEl.style.display = '';
  grid.style.display = 'none';
  try {
    let data = null;
    if (CODEX_DATA_CACHE && codexDataLoaded && !force) {
      data = CODEX_DATA_CACHE;
      if (!CODEX_ENTITY_REGEX || !CODEX_ENTITY_INDEX || CODEX_ENTITY_INDEX.size === 0) {
        buildCodexEntityIndex(data);
      }
    } else {
      const res = await fetch(CODEX_URL + '?t=' + Date.now());
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      data = await res.json();
      CODEX_DATA_CACHE = data;
      codexDataLoaded = true;
      buildCodexEntityIndex(data);
    }
    codexLoaded = true;
    renderCodex(data);
  } catch (err) {
    console.error(err);
    statusEl.innerHTML = errorBoxHtml('âš  The Codex is Lost', `Could not load: ${err && err.message ? err.message : String(err)}`);
    statusEl.style.display = '';
  }
}

// â”€â”€ Tab Switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function switchTab(tab) {
  currentTab = tab;
  const talesView = document.getElementById('tales-view');
  const charView  = document.getElementById('char-view');
  const tabTales  = document.getElementById('tab-tales');
  const tabChars  = document.getElementById('tab-characters');
  if (tab === 'tales') {
    talesView.style.display = '';
    charView.style.display  = 'none';
    tabTales.classList.add('active');
    tabTales.setAttribute('aria-selected', 'true');
    tabChars.classList.remove('active');
    tabChars.setAttribute('aria-selected', 'false');
  } else {
    talesView.style.display = 'none';
    charView.style.display  = 'block';
    tabChars.classList.add('active');
    tabChars.setAttribute('aria-selected', 'true');
    tabTales.classList.remove('active');
    tabTales.setAttribute('aria-selected', 'false');
    loadCodex(true);
  }
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// â”€â”€ Archive Drawer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openArchive() {
  document.getElementById('archive-drawer').classList.add('open');
  document.getElementById('archive-overlay').classList.add('open');
  document.getElementById('archive-overlay').setAttribute('aria-hidden', 'false');
  if (!archiveLoaded) loadArchiveIndex();
}
function closeArchive() {
  document.getElementById('archive-drawer').classList.remove('open');
  document.getElementById('archive-overlay').classList.remove('open');
  document.getElementById('archive-overlay').setAttribute('aria-hidden', 'true');
}
async function loadArchiveIndex() {
  const listEl = document.getElementById('archive-list');
  listEl.innerHTML = '<div class="archive-loading"><span class="spinner"></span> Consulting the grimoireâ€¦</div>';
  try {
    const res = await fetch(ARCHIVE_IDX_URL + '?t=' + Date.now());
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    const idx = await res.json();
    archiveLoaded = true;
    const today = todayStr();
    const dates = idx.dates || [];
    if (dates.length === 0) {
      listEl.innerHTML = '<div class="archive-empty"><em>The vault is empty.<br>Return tomorrow.</em></div>';
      return;
    }
    listEl.innerHTML = '';
    let issueNum = dates.length;
    dates.forEach((date) => {
      const isToday = date === today;
      const btn = document.createElement('button');
      btn.className = 'archive-entry' + (isToday ? ' today' : '') + (date === currentDate ? ' active' : '');
      btn.dataset.date = date;
      btn.innerHTML = `
        <div class="archive-entry-label">Issue ${String(issueNum).padStart(3, '0')}</div>
        <div class="archive-entry-date">
          ${escHtml(formatDate(date))}
          ${isToday ? '<span class="archive-entry-today-badge">Today</span>' : ''}
        </div>
      `;
      btn.addEventListener('click', () => {
        if (currentTab !== 'tales') switchTab('tales');
        if (isToday) { loadTodayStories(); closeArchive(); }
        else { loadArchiveDate(date); }
      });
      listEl.appendChild(btn);
      issueNum--;
    });
  } catch (err) {
    console.error(err);
    listEl.innerHTML = `<div class="archive-empty"><em>Could not open the vault.<br>${escHtml(err.message)}</em></div>`;
  }
}

// â”€â”€ Event Listeners â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('tab-tales').addEventListener('click', () => switchTab('tales'));
document.getElementById('tab-characters').addEventListener('click', () => switchTab('characters'));
document.querySelectorAll('.codex-filter-btn').forEach(btn => {
  btn.addEventListener('click', () => applyCodexFilter(btn.dataset.type));
});

// Codex organize controls
document.getElementById('codex-organize-mode').addEventListener('change', (e) => {
  activeCodexOrganizeMode = e.target.value || 'default';
  refreshCodexLabelOptions();
  applyCodexOrganization();
});
document.getElementById('codex-organize-label').addEventListener('change', (e) => {
  activeCodexOrganizeLabel = e.target.value || 'all';
  applyCodexOrganization();
});
document.getElementById('archive-btn').addEventListener('click', openArchive);
document.getElementById('archive-close').addEventListener('click', closeArchive);
document.getElementById('archive-overlay').addEventListener('click', closeArchive);

// Story modal close
document.getElementById('story-modal-close').addEventListener('click', closeStoryModal);
document.getElementById('story-modal-overlay').addEventListener('click', closeStoryModal);

// Codex modal close
document.getElementById('codex-modal-close').addEventListener('click', closeCodexModal);
document.getElementById('codex-modal-overlay').addEventListener('click', closeCodexModal);

// Entity badges under stories / in story modal
document.addEventListener('click', (e) => {
  const btn = e.target && e.target.closest ? e.target.closest('.entity-badge') : null;
  if (!btn) return;
  const key = btn.dataset.entityKey || '';
  if (!key) return;
  const typeHint = btn.dataset.entityType || '';
  openCodexEntryByKey(key, typeHint);
});

// Escape key: close story modal first, otherwise close archive drawer.
document.addEventListener('keydown', (e) => {
  const modalOpen = document.getElementById('story-modal').classList.contains('open');
  const codexOpen = document.getElementById('codex-modal').classList.contains('open');

  if (e.key === 'Escape') {
    if (codexOpen) { closeCodexModal(); return; }
    if (modalOpen) { closeStoryModal(); return; }
    closeArchive();
    return;
  }

  if (!modalOpen) return;
  if (!Array.isArray(STORY_MODAL_APPEARANCES) || STORY_MODAL_APPEARANCES.length <= 1) return;

  if (e.key === 'ArrowLeft' && STORY_MODAL_INDEX > 0) {
    const nextIdx = STORY_MODAL_INDEX - 1;
    const app = STORY_MODAL_APPEARANCES[nextIdx];
    openStoryModalByAppearance(app.date, app.title, { appearances: STORY_MODAL_APPEARANCES, index: nextIdx });
  }
  if (e.key === 'ArrowRight' && STORY_MODAL_INDEX < STORY_MODAL_APPEARANCES.length - 1) {
    const nextIdx = STORY_MODAL_INDEX + 1;
    const app = STORY_MODAL_APPEARANCES[nextIdx];
    openStoryModalByAppearance(app.date, app.title, { appearances: STORY_MODAL_APPEARANCES, index: nextIdx });
  }
});

// â”€â”€ Boot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('today-date').textContent = formatDate(todayStr());
{
  const hint = hostingHintHtml();
  if (hint) {
    setStatus(errorBoxHtml('âš  Cannot Run Here', 'This page canâ€™t fetch its JSON data from this location.'));
  } else {
    loadTodayStories();
  }
}
</script>
</body>
</html>
